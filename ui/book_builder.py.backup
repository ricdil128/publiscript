"""
Builder principale per la creazione di libri.
"""

import re
import time
import logging
import os
import json
import traceback
import gradio as gr
from datetime import datetime
from pathlib import Path
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.keys import Keys

from ai_interfaces.genspark_driver import setup_browser, check_login, create_fresh_chat, get_input_box, clear_chat
from framework.crisp_framework import CRISPFramework
from .chat_manager import ChatManager
from .cooldown_manager import CooldownManager
from .database_manager import DatabaseManager  # Importiamo il DatabaseManager

class AIBookBuilder:
    def __init__(self):
        self.cooldown_manager = CooldownManager()
        self.chat_manager = ChatManager(parent=self)
        self.is_logged_in = False
        self.driver = None
        self.log_history = []
        self.chat_manager = ChatManager(parent=self)  # Passa il riferimento di s√© stesso
        self.current_analysis = None      
        self.question_status = {}  # Dizionario per tracciare lo stato delle domande     
        
        # Inizializziamo il DatabaseManager
        self.db_manager = DatabaseManager(
            project_db_path="crisp_projects.db", 
            log_callback=self.add_log
        )

        import logging
        logger = logging.getLogger("AIBookBuilder")
        
        # Inizializza il framework CRISP
        self.crisp = CRISPFramework(
            prompt_dir="prompt_crisp",
    	    project_db_path="crisp_projects.db",
    	    driver=None  # Il driver verr√† impostato dopo la connessione
	)
        
        # Rimuovo il percorso manuale: uso sempre CRISP
        self.use_crisp = True
        
        # Tipi di libro disponibili
        self.book_types = [
            "Manuale (Non-Fiction)",
            "Ricettario",
            "Craft & Hobby",
            "Survival & Outdoor",
            "Test Study"
        ]

        # Mercati Amazon disponibili
        self.markets = {
            "USA": "Amazon.com",
            "Italia": "Amazon.it",
            "Francia": "Amazon.fr",
            "Inghilterra": "Amazon.co.uk",
            "Canada": "Amazon.ca",
            "Australia": "Amazon.com.au",
            "Spagna": "Amazon.es",
            "Germania": "Amazon.de"
        }
        
        # Prompt di analisi default
        self.default_analysis_prompt = """1) Analizza la concorrenza su {amazon_url} per la keyword {keyword} nel mercato {market}: elenca i primi 10 risultati Amazon con titolo, sottotitolo, BSR, prezzo, recensioni, formato, keyword usate nei titoli, pattern visivi delle copertine; aggiungi dati da Google Trends, query emergenti e insight dai social; concludi con una tabella di sintesi e commento su cosa domina e cosa manca; scrivi in {lingua}, titoli e keyword nella lingua del {market}; concludi con la parola FINE.
2) Valuta la profittabilit√† e competitivit√† della keyword {keyword} su {amazon_url} nel mercato {market}: considera vendite mensili stimate per range di BSR, prezzo medio osservabile, margini potenziali di guadagno per autore KDP, numero e qualit√† dei competitor diretti, livello di saturazione della nicchia, e difficolt√† stimata nel posizionarsi; concludi con 3 bullet: ‚ÄúAlta opportunit√† se‚Ä¶‚Äù, ‚ÄúModerata se‚Ä¶‚Äù, ‚ÄúBassa se‚Ä¶‚Äù; scrivi in {lingua}, titoli e keyword nella lingua del {market}; concludi con la parola FINE.
3) Analizza i 3 migliori concorrenti per la keyword {keyword} su {amazon_url} nel mercato {market}: mostra per ciascuno titolo, sottotitolo, BSR, recensioni, struttura (indice se disponibile), copertina (stile, elementi distintivi), pricing, e bonus offerti; concludi con una mini-tabella comparativa e insight su ci√≤ che li rende forti; scrivi in {lingua}, titoli e keyword nella lingua del {market}; concludi con la parola FINE.
4) Definisci una buyer persona sintetica per {keyword} nel mercato {market}: includi et√†, professione, obiettivi, problemi, livello di consapevolezza e grado di urgenza; completa con 3 bullet: ‚ÄúCosa cerca‚Äù, ‚ÄúCosa teme‚Äù, ‚ÄúCosa sogna‚Äù; se possibile, assegnale un nome simbolico e una frase tipo ‚ÄúVorrei un libro che‚Ä¶‚Äù; scrivi in {lingua}, titoli e keyword nella lingua del {market}; concludi con la parola FINE.
5) Identifica i principali gap nei libri esistenti su {amazon_url} per {keyword}: analizza recensioni negative (1‚òÖ‚Äì2‚òÖ) per evidenziare frustrazioni comuni, bisogni insoddisfatti, parti assenti o trattate male; indica almeno 3 aree tematiche mancanti e il valore potenziale che avrebbero se inserite in un nuovo libro; concludi con una tabella "Gap vs Opportunit√†"; scrivi in {lingua}, titoli e keyword nella lingua del {market}; concludi con la parola FINE.
6) Genera 3 idee editoriali differenzianti per un nuovo libro su {keyword} nel mercato {market}: per ciascuna proposta definisci l‚Äôangolo editoriale, l‚Äôapproccio (pratico, teorico, visuale‚Ä¶), il target specifico e una USP sintetica (max 2 righe) che risponda ai bisogni emersi; scrivi in {lingua}, titoli e keyword nella lingua del {market}; concludi con la parola FINE.
7) Valuta le 3 idee editoriali proposte nel punto precedente e scegli la migliore: motiva la scelta sulla base del potenziale commerciale, dell‚Äôoriginalit√†, della compatibilit√† con la buyer persona e dei gap riscontrati; scrivi in {lingua}, titoli e keyword nella lingua del {market}; concludi con la parola FINE.
8) In base all‚Äôidea selezionata, proponi 3 titoli con relativo sottotitolo (titolo + sottotitolo per ciascuna variante) e poi genera 3 diversi indici coerenti, ciascuno con almeno 6 capitoli principali e colonna ‚ÄúObiettivo del capitolo‚Äù; per i titoli, valuta chiarezza, potere evocativo, e potenziale di vendita; scrivi in {lingua}, titoli e keyword nella lingua del {market}; concludi con la parola FINE.
 """

    # Metodi che delegano le operazioni al DatabaseManager
    def recupera_ultimo_progetto(self):
        """Delega l'operazione al DatabaseManager"""
        return self.db_manager.recupera_ultimo_progetto()

    def ripristina_ultima_analisi(self):
        """Ripristina l'ultima analisi dal database."""
        return self.db_manager.ripristina_ultima_analisi(self.crisp, self.driver, self.chat_manager)

    def ripristina_analisi_da_database(self, selected_index, start_from_phase=None):
        """Ripristina un'analisi dal database."""
        result = self.db_manager.ripristina_analisi_da_database(selected_index, start_from_phase, self.driver, self.crisp, self.chat_manager)
    
        # Se risultato √® un dizionario, contiene l'analisi da ripristinare
        if isinstance(result, dict) and 'project_id' in result:
            # Salviamo i dati di ripristino
            self.current_analysis = result
            project_id = result['project_id']
            project_data = result['project_data']
            start_from_phase = result['current_phase']
        
            # Creiamo una nuova chat e carichiamo il contesto
            if self.driver:
                self.add_log(f"Creazione nuova chat per la ripresa dell'analisi...")
                create_fresh_chat(self.driver, "context.txt")
        
                # Prepara messaggio di ripresa
                input_box = get_input_box(self.driver)
                resume_message = f"""
                Sto riprendendo l'analisi per il progetto: {project_data.get('PROJECT_NAME', 'N/A')}
                Keyword: {project_data.get('KEYWORD', 'N/A')}
        
                Siamo arrivati alla fase {start_from_phase}.
                Per favore, continua l'analisi da questa fase.
                """
        
                # Invia il messaggio
                chunks = [resume_message[i:i+200] for i in range(0, len(resume_message), 200)]
                for chunk in chunks:
                    input_box.send_keys(chunk)
                    time.sleep(0.5)
        
                send_button = self.driver.find_element(By.CSS_SELECTOR, "div.search-input-wrapper div.input-icon")
                send_button.click()
        
                time.sleep(5)
        
                # Aggiorna l'interfaccia
                self.add_log(f"‚úÖ Analisi ripristinata con successo. Pronta per continuare dalla fase {start_from_phase}")
            else:
                self.add_log("‚ùå Browser non inizializzato. Connettiti prima di continuare")
    
        return self.chat_manager.get_log_history_string()

    def resume_analysis(self, project_id, selected_phases=None):
        """
        Riprende un'analisi esistente eseguendo fasi specifiche.
    
        Args:
            project_id: ID del progetto da riprendere
            selected_phases: Lista di fasi da eseguire (opzionale)
        
        Returns:
            str: Log dell'operazione
        """
        try:
            self.add_log(f"üîÑ Ripresa analisi per progetto ID: {project_id}")
        
            # Recupera i dati del progetto
            project_data = self.crisp._load_project_data(project_id)
            if not project_data:
                return self.add_log(f"‚ùå Progetto ID {project_id} non trovato!")
        
            # Imposta il progetto come analisi corrente
            self.current_analysis = {
                'crisp_project_id': project_id,
                'project_data': project_data,
                'KEYWORD': project_data.get('KEYWORD', 'unknown')
            }
        
            # Se non ci sono fasi specificate, usa tutte le rimanenti
            if not selected_phases:
                # Determina qual √® l'ultima fase eseguita
                last_phase = self.crisp._get_last_executed_step(project_id)
                if last_phase:
                    # Trova l'indice della fase nell'elenco completo
                    all_phases = ["CM-1", "CM-2", "CM-3", "CM-4", "CM-5", "CM-6", "CM-7", "CM-8"]
                    try:
                        last_index = all_phases.index(last_phase)
                        # Seleziona tutte le fasi successive
                        selected_phases = all_phases[last_index+1:]
                    except ValueError:
                        # Se la fase non √® nell'elenco standard, usa tutte le fasi
                        selected_phases = all_phases
                else:
                    # Se non c'√® una fase precedente, usa tutte le fasi
                    selected_phases = ["CM-1", "CM-2", "CM-3", "CM-4", "CM-5", "CM-6", "CM-7", "CM-8"]
        
            # Se ci sono fasi da eseguire, procedi
            if selected_phases:
                self.add_log(f"üîç Ripresa con fasi: {', '.join(selected_phases)}")
            
                # Definisci la funzione executor
                def process_prompt(prompt_text):
                    self.add_log(f"Elaborazione prompt: {len(prompt_text)} caratteri")
                    response = self.send_to_genspark(prompt_text)
                    return response
            
                # Esegui le fasi selezionate una per una
                execution_history = []
                current_data = project_data.copy()
            
                for phase_id in selected_phases:
                    self.add_log(f"üîÑ Esecuzione fase {phase_id}")
                
                    # Esegui la singola fase
                    updated_data, phase_result, extracted_data = self.crisp.execute_step(
                        phase_id, 
                        current_data.copy(), 
                        process_prompt
                    )
                
                    # Aggiorna i dati correnti con i risultati della fase
                    current_data.update(updated_data)
                
                    # Aggiungi alla storia di esecuzione
                    execution_history.append({
                        'step_id': phase_id,
                        'result': phase_result,
                        'extracted_data': extracted_data
                    })
            
                # Aggiorna l'analisi corrente con i nuovi dati
                self.current_analysis['project_data'] = current_data
                self.current_analysis['execution_history'] = execution_history
            
                self.add_log("‚úÖ Ripresa analisi completata con successo")
            else:
                self.add_log("‚ö†Ô∏è Nessuna fase da eseguire - l'analisi √® gi√† completa")
        
            # Carica i risultati aggiornati
            self.load_analysis_results()
        
            return self.chat_manager.get_log_history_string()
        
        except Exception as e:
            self.add_log(f"‚ùå Errore nella ripresa dell'analisi: {str(e)}")
            import traceback
            self.add_log(traceback.format_exc())
            return self.chat_manager.get_log_history_string()

    def load_projects_list(self):
        """Delega l'operazione al DatabaseManager"""
        # Ottieni una lista di stringhe semplici dal DatabaseManager
        project_names = self.db_manager.load_projects_list()
    
        # Il dropdown √® configurato con type="value", quindi pu√≤ accettare una lista di stringhe semplici
        # Non √® necessario convertire in tuple (index, value)
        if hasattr(self, 'projects_list') and self.projects_list is not None:
            self.projects_list.choices = project_names
            self.add_log(f"‚úÖ Dropdown aggiornato con {len(project_names)} progetti")
    
        return project_names

    def check_existing_analysis(self, keyword):
        """Verifica se esiste gi√† un'analisi per la keyword specificata."""
        return self.db_manager.check_existing_analysis(keyword)

    def load_project_details(self, selected_index):
        """Delega l'operazione al DatabaseManager"""
        return self.db_manager.load_project_details(selected_index)

    def diagnose_and_fix_database(self):
        """Delega l'operazione al DatabaseManager"""
        return self.db_manager.diagnose_and_fix_database()

    def export_project(self, selected_index):
        """Delega l'operazione al DatabaseManager"""
        return self.db_manager.export_project(selected_index)

    def update_project_count(self):
        """Delega l'operazione al DatabaseManager"""
        return self.db_manager.update_project_count()

    def delete_project(self, project_display_name):
        """Delega l'operazione al DatabaseManager"""
        result = self.db_manager.delete_project(project_display_name)
    
        # Aggiorna l'elenco dei progetti dopo l'eliminazione
        self.db_manager.load_projects_list()
    
        return result

    def create_test_project(self):
        """Delega l'operazione al DatabaseManager"""
        return self.db_manager.create_test_project()

    def search_projects(self, keyword=""):
        """Delega l'operazione al DatabaseManager"""
        return self.db_manager.search_projects(keyword)

    def get_database_stats(self):
        """Delega l'operazione al DatabaseManager"""
        return self.db_manager.get_database_stats()

    # FINE - Metodi che delegano le operazioni al DatabaseManager

    def add_log(self, message):
            """Delega il logging al ChatManager"""
            return self.chat_manager.add_log(message)
        
    def log_prompt_location(self, prompt_id, section_number, action, details=None):
        """Delega il tracciamento della posizione al ChatManager"""
        return self.chat_manager.log_prompt_location(prompt_id, section_number, action, details) 

    def connect_callback(self):
        try:
            # Variabile globale per memorizzare la funzione originale
            global original_get
        
            # Se siamo gi√† loggati e il driver √® attivo, evitiamo di ricreare la sessione
            if self.is_logged_in and self.driver:
                # Aggiungiamo la patch di monitoraggio se non l'abbiamo gi√† fatto
                if not hasattr(self, '_get_patched') or not self._get_patched:
                    original_get = self.driver.get
                
                    def log_get_call(url):
                        print(f"DEBUG_URL: Chiamata a driver.get() con URL: {url}")
                        self.add_log(f"DEBUG_URL: Navigazione a: {url}")
                        # Chiamiamo la funzione originale
                        return original_get(url)
                
                    self.driver.get = log_get_call
                    self._get_patched = True
                    self.add_log("DEBUG_URL: Monitoraggio navigazione attivato")

                timestamp = datetime.now().strftime('%H:%M:%S')
                log_message = f"[{timestamp}] Sei gi√† connesso a Genspark. Sessione attiva mantenuta."
                self.log_history.append(log_message)

                # IMPORTANTE: Verifica che siamo nella pagina di chat corretta
                self.add_log("Verifica URL corrente ed eventuale reindirizzamento alla chat...")
                current_url = self.driver.current_url
                self.add_log(f"DEBUG_URL: URL attuale prima della verifica: {current_url}")

                if "/chat" not in current_url.lower():
                    self.add_log(f"URL corrente non √® una pagina di chat: {current_url}")
                    self.add_log("Reindirizzamento alla pagina di chat...")
                    # Questo viene monitorato grazie al nostro patch
                    # self.driver.get("https://genspark.ai")
                    # time.sleep(5)
                    # self.add_log(f"DEBUG_URL: URL dopo reindirizzamento: {self.driver.current_url}")

                return self.chat_manager.get_log_history_string(), "**Stato**: Connesso - Sessione attiva"

            # Salviamo temporaneamente i messaggi di log
            logs = []

            # Aggiungiamo il primo messaggio
            timestamp = datetime.now().strftime('%H:%M:%S')
            logs.append(f"[{timestamp}] Avvio connessione browser...")

            # Avviamo il browser
            self.driver = setup_browser()
            self.add_url_change_monitor()
            self.crisp.driver = self.driver  # Aggiorna il riferimento al driver nel framework CRISP

            # Aggiungiamo la patch di monitoraggio per il nuovo driver
            original_get = self.driver.get
        
            def log_get_call(url):
                print(f"DEBUG_URL: Chiamata a driver.get() con URL: {url}")
                self.add_log(f"DEBUG_URL: Navigazione a: {url}")
                # Tracciamo anche da dove viene chiamata la funzione
                import traceback
                caller = traceback.extract_stack()[-2]
                print(f"DEBUG_URL: Chiamata da {caller.filename}:{caller.lineno}")
                # Chiamiamo la funzione originale
                return original_get(url)
        
            self.driver.get = log_get_call
            self._get_patched = True
            self.add_log("DEBUG_URL: Monitoraggio navigazione attivato per nuovo driver")

            # Dopo aver avviato il browser, aggiungi:
            self.add_log(f"Browser avviato: {self.driver is not None}")
            self.add_log("Tentativo di navigazione a Genspark...")
            # Questo viene monitorato grazie al nostro patch
            # self.driver.get("https://genspark.ai")
            # self.add_log(f"Navigazione richiesta, URL attuale: {self.driver.current_url}")

            # IMPORTANTE: Naviga DIRETTAMENTE alla pagina di chat, non alla home
            self.add_log("Navigazione diretta alla pagina di chat...")
            # Questo viene monitorato grazie al nostro patch
            self.driver.get("https://genspark.ai")
            time.sleep(7)  # Attesa pi√π lunga per il caricamento completo

            # Verifica URL dopo la navigazione
            current_url = self.driver.current_url
            self.add_log(f"URL dopo navigazione: {current_url}")

            # Se siamo stati reindirizzati alla home o altra pagina, riprova con approccio alternativo
            if "/chat" not in current_url.lower():
                self.add_log("Reindirizzato a URL non di chat, provo approccio alternativo...")

                # Prima vai alla home
                # Questo viene monitorato grazie al nostro patch
                self.driver.get("https://genspark.ai/")
                time.sleep(3)

                # Cerca esplicitamente un link alla chat
                # chat_links = self.driver.find_elements(By.XPATH, "//a[contains(@href, '/chat')]")
                # if chat_links:
                #     self.add_log("Trovato link alla chat, cliccando...")
                #     self.add_log(f"DEBUG_URL: Cliccando link con href: {chat_links[0].get_attribute('href')}")
                #     chat_links[0].click()
                #     time.sleep(5)
                #     self.add_log(f"DEBUG_URL: URL dopo click: {self.driver.current_url}")
                # else:
                #     # Se non trovi link, prova URL diretto di nuovo
                #     self.add_log("Nessun link trovato, riprovo URL diretto con percorso completo...")
                #     # Questo viene monitorato grazie al nostro patch
                #     self.driver.get("https://genspark.ai")
                #     time.sleep(5)

            # Verifica dell'URL finale
            final_url = self.driver.current_url
            self.add_log(f"URL finale: {final_url}")

            # Controlliamo il login
            self.add_log("DEBUG_URL: Verificando login...")
            login_result = check_login(self.driver)
            self.add_log(f"DEBUG_URL: Risultato check_login: {login_result}")
        
            if not login_result:
                timestamp = datetime.now().strftime('%H:%M:%S')
                logs.append(f"[{timestamp}] ATTENZIONE: Completa manualmente il login su Genspark.ai.")
                timestamp = datetime.now().strftime('%H:%M:%S')
                logs.append(f"[{timestamp}] Assicurati di essere nella pagina della chat prima di continuare.")

                # Aggiungi un input per aspettare che l'utente finisca di fare login
                timestamp = datetime.now().strftime('%H:%M:%S')
                logs.append(f"[{timestamp}] Premi il pulsante 'Connetti' nuovamente dopo aver effettuato il login.")
        
                # Aggiorniamo la cronologia dei log attraverso il ChatManager
                for log_message in logs:
                    # Rimuoviamo il timestamp se gi√† presente nel messaggio
                    if log_message.startswith('[') and ']' in log_message:
                        clean_message = log_message.split(']', 1)[1].strip()
                        self.chat_manager.add_log(clean_message)
                    else:
                        self.chat_manager.add_log(log_message)

                return self.chat_manager.get_log_history_string(), "**Stato**: Login richiesto"
 
                # Salva i cookie per usi futuri
                try:
                    import pickle
                    cookies = self.driver.get_cookies()
                    pickle.dump(cookies, open("genspark_cookies.pkl", "wb"))
                    timestamp = datetime.now().strftime('%H:%M:%S')
                    logs.append(f"[{timestamp}] Cookie salvati con successo!")
                except Exception as e:
                    timestamp = datetime.now().strftime('%H:%M:%S')
                    logs.append(f"[{timestamp}] Errore nel salvataggio dei cookie: {str(e)}")

            # Impostiamo lo stato di login
            self.is_logged_in = True

            # Aggiorniamo la cronologia dei log e restituiamo il tutto
            for log_message in logs:
                self.chat_manager.add_log(log_message)
            return self.chat_manager.get_log_history_string(), "**Stato**: Connesso"
        except Exception as e:
            # In caso di errore
            self.chat_manager.add_log(f"Errore: {str(e)}")
            
            # Aggiungiamo il traceback per debug
            import traceback
            tb = traceback.format_exc()
            print(f"DEBUG_URL: Eccezione in connect_callback:\n{tb}")
            
            return self.chat_manager.get_log_history_string(), "**Stato**: Errore di connessione"
        
            # Aggiungiamo il traceback per debug
            import traceback
            tb = traceback.format_exc()
            print(f"DEBUG_URL: Eccezione in connect_callback:\n{tb}")
        
            return self.chat_manager.get_log_history_string(), "**Stato**: Errore di connessione"

    def add_url_change_monitor(self):
        """Aggiunge uno script al browser per monitorare i cambiamenti di URL"""
        if not hasattr(self, 'driver') or self.driver is None:
            print("DEBUG_URL: Impossibile installare monitor URL - driver non disponibile")
            return False
        
        script = """
        let lastUrl = window.location.href;
        console.log('Monitor URL inizializzato con URL: ' + lastUrl);
    
        // Funzione per controllare periodicamente l'URL
        function checkUrlChange() {
            const currentUrl = window.location.href;
            if (currentUrl !== lastUrl) {
                console.log('URL CAMBIATO da: ' + lastUrl + ' a: ' + currentUrl);
                lastUrl = currentUrl;
            }
            setTimeout(checkUrlChange, 1000);  // Controlla ogni secondo
        }
    
        // Avvia il controllo
        checkUrlChange();
    
        // Restituisci true per confermare l'installazione
        return true;
        """
    
        try:
            result = self.driver.execute_script(script)
            print(f"DEBUG_URL: Monitor di cambio URL installato nel browser: {result}")
            return True
        except Exception as e:
            print(f"DEBUG_URL: Errore nell'installazione del monitor URL: {str(e)}")
            return False

    
    # Definisci una funzione executor che invia il prompt a Genspark
def _analyze_market_crisp(self, book_type, keyword, language, market, selected_phases=None):
    """
    Analizza il mercato usando il framework CRISP 5.0.

    Args:
        book_type: Tipo di libro
        keyword: Keyword principale
        language: Lingua dell'output
        market: Mercato di riferimento
        selected_phases: Lista di fasi selezionate da eseguire (opzionale)

    Returns:
        str: Log dell'operazione
    """
    try:
        self.add_log(f"Avvio analisi CRISP 5.0 per: {keyword}")
    
        # Converti selected_phases in una lista se √® una stringa singola
        if isinstance(selected_phases, str):
            selected_phases = [selected_phases]
    
        # Log delle fasi selezionate
        if selected_phases:
            self.add_log(f"üîç Esecuzione selettiva delle fasi CRISP: {', '.join(selected_phases)}")
        else:
            self.add_log("üîç Esecuzione di tutte le fasi CRISP")

        # Crea un nuovo progetto nel database CRISP
        project_name = f"{keyword} - {datetime.now().strftime('%Y-%m-%d')}"
        project_id = self.crisp.create_project(project_name)

        # Prepara i dati iniziali del progetto
        initial_data = {
            "PROJECT_ID": project_id,
            "PROJECT_NAME": project_name,
            "KEYWORD": keyword,
            "LIBRO_TIPO": book_type,
            "LINGUA": language, 
            "MERCATO": market,
            "AMAZON_URL": self.markets.get(market, "Amazon.com")
        }
    
        # Salva il riferimento al progetto CRISP corrente
        self.current_analysis = {
            'crisp_project_id': project_id,
            'project_data': initial_data,
            'KEYWORD': keyword
        }

        # Funzione semplice che processa il prompt
        def process_prompt(prompt_text):
            self.add_log(f"Elaborazione prompt: {len(prompt_text)} caratteri")

            # Sostituisci le variabili nel prompt
            processed_text = prompt_text
            if "{KEYWORD}" in processed_text:
                processed_text = processed_text.replace("{KEYWORD}", keyword)
            if "{MERCATO}" in processed_text:
                processed_text = processed_text.replace("{MERCATO}", market)

            # Invia il prompt a Genspark
            response = self.send_to_genspark(processed_text)

            # Pulisci la risposta se contiene "FINE"
            if response and "FINE" in response.upper():
                response = response[:response.upper().find("FINE")].strip()

            return response

        # SOLUZIONE - Patching del metodo execute_step
        original_execute_step = self.crisp.execute_step

        def patched_execute_step(prompt_id, project_data, executor_func):
            """
            Versione patchata di execute_step che processa una sezione alla volta.
            """
            self.add_log(f"Esecuzione patchata di step {prompt_id}")

            try:
                # Carica i dati del prompt
                prompt_data = self.crisp.load_prompt(prompt_id)
                prompt_content = prompt_data["content"]

                # Dividi il contenuto in sezioni
                sections = prompt_content.split("\n---\n")
                numbered_sections = []
                for section in sections:
                    section = section.strip()
                    if re.match(r'^\d+\.', section):
                        numbered_sections.append(section)

                if not numbered_sections:
                    numbered_sections = [prompt_content]

                self.log_prompt_location(prompt_id, "ALL", f"Trovate {len(numbered_sections)} sezioni")

                # Processa ogni sezione e raccogli le risposte
                all_responses = []
                for i, section in enumerate(numbered_sections):
                    section_number = i + 1
                    self.log_prompt_location(prompt_id, section_number, "Inizio elaborazione")

                    # Pulisci la chat prima di ogni sezione
                    try:
                        clear_chat_button = self.driver.find_element(By.CSS_SELECTOR, "button[aria-label='Clear chat']")
                        clear_chat_button.click()
                        time.sleep(2)
                    except Exception as e:
                        self.log_prompt_location(prompt_id, section_number, "Errore pulizia chat", str(e))

                    # Processa la sezione
                    processed_section = replace_variables(section.strip(), project_data)
                    response = self.send_to_genspark(processed_section, prompt_id=prompt_id, section_number=section_number)
        
                    # Log della risposta
                    response_preview = response[:100] + "..." if response else "Nessuna risposta"
                    self.log_prompt_location(prompt_id, section_number, "Risposta ricevuta", response_preview)
        
                    all_responses.append(response)

                    # Attendi che la risposta sia completa
                    if "FINE_RISPOSTA" not in response:
                        self.log_prompt_location(prompt_id, section_number, "Attesa completamento")
                        time.sleep(10)

                # Combina tutte le risposte
                full_result = "\n\n".join(all_responses)

                # Estrai i dati solo dopo aver processato tutte le sezioni
                extracted_data = self.crisp.extract_data(full_result, prompt_id)

                # Salva il risultato nel database
                if "PROJECT_ID" in project_data:
                    self.crisp._save_result_to_db(
                        project_data["PROJECT_ID"],
                        prompt_id,
                        full_result,
                        extracted_data
                    )

                # Aggiorna i dati del progetto
                project_data.update(extracted_data)

                return project_data, full_result, extracted_data

            except Exception as e:
                self.log_prompt_location(prompt_id, "ERROR", f"Errore in patched_execute_step: {str(e)}")
                raise

        # Sostituisci temporaneamente il metodo execute_step
        self.crisp.execute_step = patched_execute_step

        # Esegui il flusso CRISP
        try:
            # Se abbiamo fasi selezionate, usa solo quelle in ordine
            if selected_phases and len(selected_phases) > 0:
                # Ordina le fasi selezionate per assicurare l'esecuzione corretta
                sorted_phases = sorted(selected_phases)
            
                self.add_log(f"‚öôÔ∏è Esecuzione fasi CRISP in ordine: {', '.join(sorted_phases)}")
            
                # Esegui ciascuna fase individualmente
                execution_history = []
                current_data = initial_data.copy()
            
                for phase_id in sorted_phases:
                    self.add_log(f"üîÑ Esecuzione fase {phase_id}")
                
                    # Esegui la singola fase
                    updated_data, phase_result, extracted_data = self.crisp.execute_step(
                        phase_id, 
                        current_data.copy(), 
                        process_prompt
                    )
                
                    # Aggiorna i dati correnti con i risultati della fase
                    current_data.update(updated_data)
                
                    # Aggiungi alla storia di esecuzione
                    execution_history.append({
                        'step_id': phase_id,
                        'result': phase_result,
                        'extracted_data': extracted_data
                    })
            
                # Risultati finali
                final_data = current_data
                self.add_log(f"‚úÖ Esecuzione delle fasi selezionate completata: {', '.join(sorted_phases)}")
            else:
                # Esegui il flusso normale dall'inizio alla fine
                self.add_log("‚öôÔ∏è Esecuzione del flusso completo CRISP")
                final_data, execution_history = self.crisp.execute_flow(
                    initial_data,
                    process_prompt,
                    start_step="CM-1"
                )
                self.add_log("‚úÖ Analisi CRISP completa eseguita con successo")
        
            # Aggiorna il riferimento all'analisi corrente
            self.current_analysis['project_data'] = final_data
            self.current_analysis['execution_history'] = execution_history
        
        finally:
            # Ripristina il metodo originale
            self.crisp.execute_step = original_execute_step

        return self.chat_manager.get_log_history_string()

    except Exception as e:
        self.add_log(f"‚ùå Errore nell'analisi CRISP: {str(e)}")
        return self.chat_manager.get_log_history_string()

    # Definisci una funzione executor che invia il prompt a Genspark
    def execute_prompt(self, prompt_text, step_id=None, project_data=None):
        """
        Funzione robusta che esegue un prompt CRISP, gestisce errori e interruzioni,
        e garantisce il completamento anche in presenza di problemi.

        Args:
            prompt_text: Testo del prompt da inviare
            step_id: ID del prompt corrente (opzionale)
            project_data: Dati del progetto per sostituire le variabili

        Returns:
            str: Risposta cumulativa da Genspark
        """
        # Inizializzazione e logging
        prompt_id_to_use = step_id if step_id else "unknown"
        self.add_log(f"üöÄ Inizio esecuzione prompt {prompt_id_to_use} ({len(prompt_text)} caratteri)")
        print(f"DEBUG: Inizio esecuzione prompt {prompt_id_to_use} ({len(prompt_text)} caratteri)")
        print(f"DEBUG: Preview prompt: {prompt_text[:200].replace(chr(10), ' ')}...")

        # Verifica browser attivo
        if not hasattr(self, 'driver') or self.driver is None:
            self.add_log("‚ö†Ô∏è Browser non attivo, impossibile procedere")
            print("DEBUG: Browser non attivo, impossibile procedere")
            return "ERRORE: Browser non inizializzato"

        # Verifica URL corrente
        try:
            current_url = self.driver.current_url
            self.add_log(f"üåê URL attuale: {current_url}")
            print(f"DEBUG: URL attuale: {current_url}")
    
            # Se non siamo in una pagina di chat, naviga a Genspark
            if not ("genspark.ai" in current_url and ("/chat" in current_url or "/agents" in current_url)):
                self.add_log("üîÑ Navigazione alla pagina di chat...")
                print("DEBUG: Navigazione alla pagina di chat...")
                self.driver.get("https://genspark.ai")
                time.sleep(10)
        except Exception as e:
            self.add_log(f"‚ö†Ô∏è Errore nella verifica URL: {str(e)}")
            print(f"DEBUG: Errore nella verifica URL: {str(e)}")

        # MODIFICA CRUCIALE: Divisione del prompt in sezioni numeriche
        import re

        # Pattern per trovare punti numerati (esempio: "1. Titolo", "2. Titolo", ecc.)
        numbered_sections = re.findall(r'(?:\n|^)(\d+\.\s+.*?)(?=(?:\n\d+\.|\n\n|$))', prompt_text, re.DOTALL)

        # Se abbiamo trovato sezioni numerate, usiamole
        if numbered_sections:
            sections = [section.strip() for section in numbered_sections]
            self.add_log(f"üìã Prompt diviso in {len(sections)} sezioni numerate")
            print(f"DEBUG: Prompt diviso in {len(sections)} sezioni numerate")
        else:
            # Fallback: dividi per righe normalmente
            sections = [line.strip() for line in prompt_text.split('\n') if line.strip()]
            self.add_log(f"üìã Prompt diviso in {len(sections)} righe (nessuna sezione numerata trovata)")
            print(f"DEBUG: Prompt diviso in {len(sections)} righe (nessuna sezione numerata trovata)")

        # Log dettagliato delle sezioni
        for i, section in enumerate(sections):
            preview = section.replace('\n', ' ')[:50]
            self.add_log(f"üìÑ Sezione {i+1}: {preview}..." + ("" if len(section) <= 50 else f" ({len(section)} caratteri)"))
            print(f"DEBUG: Sezione {i+1}: {preview}..." + ("" if len(section) <= 50 else f" ({len(section)} caratteri)"))

        # Variabili di monitoraggio globali
        max_global_retries = 3
        global_retry_count = 0
        cumulative_response = []

        # Loop di ripetizione globale per il prompt intero
        while global_retry_count < max_global_retries:
            try:
                self.add_log(f"üìù Tentativo globale {global_retry_count+1}/{max_global_retries}")
                print(f"DEBUG: Tentativo globale {global_retry_count+1}/{max_global_retries}")
        
                # Pulizia dell'interfaccia prima di iniziare
                try:
                    clear_chat(self.driver)
                    self.add_log("üßπ Chat pulita all'inizio dell'esecuzione")
                    print("DEBUG: Chat pulita all'inizio dell'esecuzione")
                    time.sleep(5)
                except Exception as clear_error:
                    self.add_log(f"‚ö†Ô∏è Impossibile pulire la chat: {str(clear_error)}")
                    print(f"DEBUG: Impossibile pulire la chat: {str(clear_error)}")
                    # Continua comunque
        
                # Processa ogni sezione
                success_sections = 0
                for i, section in enumerate(sections):
                    self.add_log(f"üìå Elaborazione sezione {i+1}/{len(sections)}...")
                    print(f"DEBUG: Elaborazione sezione {i+1}/{len(sections)}...")
            
                    # Sostituzione variabili avanzata
                    processed_section = self.replace_variables_advanced(section, project_data)
                    preview = processed_section.replace('\n', ' ')[:50]
                    self.add_log(f"‚úèÔ∏è Sezione processata: {preview}..." + 
                                ("" if len(processed_section) <= 50 else f" ({len(processed_section)} caratteri)"))
                    print(f"DEBUG: Sezione processata: {preview}..." + 
                         ("" if len(processed_section) <= 50 else f" ({len(processed_section)} caratteri)"))
            
                    # Verifica placeholder non risolti
                    unresolved = self.check_unresolved_placeholders(processed_section)
                    if unresolved:
                        self.add_log(f"‚ö†Ô∏è Placeholders non risolti: {unresolved}")
                        print(f"DEBUG: Placeholders non risolti: {unresolved}")
                        # Continua comunque, ma potrebbe causare problemi
            
                    # Tentativi per sezione singola
                    section_retry_count = 0
                    max_section_retries = 3
                    section_success = False
            
                    while section_retry_count < max_section_retries and not section_success:
                        try:
                            self.add_log(f"üîÑ Tentativo {section_retry_count+1}/{max_section_retries} per sezione {i+1}")
                            print(f"DEBUG: Tentativo {section_retry_count+1}/{max_section_retries} per sezione {i+1}")
                    
                            # Sistema avanzato di pulizia input
                            input_box = self.get_clean_input_box()
                            if not input_box:
                                raise Exception("Impossibile ottenere o pulire la casella di input")
                    
                            # Inserimento testo sicuro - carattere per carattere per maggiore affidabilit√†
                            self.add_log(f"‚å®Ô∏è Inserimento testo carattere per carattere...")
                            print(f"DEBUG: Inserimento testo carattere per carattere... ({len(processed_section)} caratteri)")
                            for char in processed_section:
                                input_box.send_keys(char)
                                time.sleep(0.008)  # Minimo ritardo per stabilit√†
                    
                            # Verifica prima dell'invio
                            time.sleep(1)
                            inserted_text = input_box.get_attribute("value")
                            if not inserted_text:
                                self.add_log("‚ö†Ô∏è Nessun testo inserito!")
                                print("DEBUG: ERRORE - Nessun testo inserito!")
                                if section_retry_count < max_section_retries - 1:
                                    section_retry_count += 1
                                    time.sleep(5)
                                    continue
                            elif len(inserted_text) < len(processed_section) * 0.9:
                                self.add_log(f"‚ö†Ô∏è Inserimento incompleto: {len(inserted_text)}/{len(processed_section)} caratteri")
                                print(f"DEBUG: ERRORE - Inserimento incompleto: {len(inserted_text)}/{len(processed_section)} caratteri")
                                if section_retry_count < max_section_retries - 1:
                                    section_retry_count += 1
                                    time.sleep(5)
                                    continue
                            else:
                                self.add_log(f"‚úÖ Testo inserito correttamente: {len(inserted_text)} caratteri")
                                print(f"DEBUG: Testo inserito correttamente: {len(inserted_text)} caratteri")
                    
                            # Invio con retry integrato
                            send_success = False
                    
                            # Metodo 1: Click standard
                            try:
                                send_button = WebDriverWait(self.driver, 15).until(
                                    EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper div.input-icon"))
                                )
                                send_button.click()
                                self.add_log("üîò Click standard sul pulsante di invio")
                                print("DEBUG: Click standard sul pulsante di invio")
                                send_success = True
                            except Exception as e1:
                                self.add_log(f"‚ö†Ô∏è Click standard fallito: {str(e1)}")
                                print(f"DEBUG: Click standard fallito: {str(e1)}")
                        
                                # Metodo 2: Click JavaScript
                                try:
                                    send_button = self.driver.find_element(By.CSS_SELECTOR, "div.search-input-wrapper div.input-icon")
                                    self.driver.execute_script("arguments[0].click();", send_button)
                                    self.add_log("üîò Click JavaScript sul pulsante di invio")
                                    print("DEBUG: Click JavaScript sul pulsante di invio")
                                    send_success = True
                                except Exception as e2:
                                    self.add_log(f"‚ö†Ô∏è Click JavaScript fallito: {str(e2)}")
                                    print(f"DEBUG: Click JavaScript fallito: {str(e2)}")
                            
                                    # Metodo 3: Tasto invio
                                    try:
                                        input_box.send_keys(Keys.RETURN)
                                        self.add_log("üîò Invio tramite tasto RETURN")
                                        print("DEBUG: Invio tramite tasto RETURN")
                                        send_success = True
                                    except Exception as e3:
                                        self.add_log(f"‚ùå Tutti i metodi di invio falliti: {str(e3)}")
                                        print(f"DEBUG: Tutti i metodi di invio falliti: {str(e3)}")
                    
                            if not send_success:
                                raise Exception("Impossibile inviare il messaggio con nessun metodo")
                    
                            # Attesa iniziale per inizio elaborazione
                            self.add_log("‚è≥ Attesa iniziale dopo invio (10 secondi)")
                            print("DEBUG: Attesa iniziale dopo invio (10 secondi)")
                            time.sleep(10)
                    
                            # Sistema di attesa adattivo
                            max_wait_cycles = 45  # ~15 minuti totali
                            stability_threshold = 5  # 5 cicli di stabilit√†
                            cycle_wait = 20  # 20 secondi per ciclo
                    
                            # Inizializzazione variabili di monitoraggio
                            last_length = 0
                            stable_count = 0
                            response_text = None
                    
                            for cycle in range(max_wait_cycles):
                                try:
                                    print(f"DEBUG: Ciclo di attesa {cycle+1}/{max_wait_cycles}")
                                
                                    # Verifica limite contesto ogni 3 cicli
                                    if cycle % 3 == 0 and self.handle_context_limit():
                                        self.add_log("‚ôªÔ∏è Limite contesto gestito durante attesa")
                                        print("DEBUG: Limite contesto gestito durante attesa")
                            
                                    # Prova diversi selettori per le risposte
                                    selectors = [
                                        ".message-content", 
                                        "div.chat-wrapper div.desc > div > div > div",
                                        "div.message div.text-wrap",
                                        ".chat-message-item .content"
                                    ]
                            
                                    # Cerca la risposta con tutti i selettori
                                    for selector in selectors:
                                        try:
                                            messages = self.driver.find_elements(By.CSS_SELECTOR, selector)
                                            if messages and len(messages) > 0:
                                                current_text = messages[-1].text.strip()
                                                if current_text:
                                                    response_text = current_text
                                                
                                                    # Debug della risposta ogni 5 cicli
                                                    if cycle % 5 == 0:
                                                        print(f"DEBUG: Salvataggio risposta - Lunghezza: {len(response_text)}")
                                                        if len(response_text) > 0:
                                                            print(f"DEBUG: Preview risposta: {response_text[:200].replace(chr(10), ' ')}...")
                                            
                                                    # Verifica terminazione esplicita
                                                    if "FINE_RISPOSTA" in response_text or "FINE" in response_text:
                                                        self.add_log(f"‚úÖ Terminatore esplicito trovato al ciclo {cycle+1}")
                                                        print(f"DEBUG: Terminatore esplicito trovato al ciclo {cycle+1}")
                                                        terminator = "FINE_RISPOSTA" if "FINE_RISPOSTA" in response_text else "FINE"
                                                        terminator_pos = response_text.find(terminator)
                                                        print(f"DEBUG: Terminatore '{terminator}' trovato alla posizione {terminator_pos}")
                                                
                                                        # Pulisci la risposta rimuovendo il terminatore
                                                        if "FINE_RISPOSTA" in response_text:
                                                            response_text = response_text.split("FINE_RISPOSTA")[0].strip()
                                                        elif "FINE" in response_text:
                                                            response_text = response_text.split("FINE")[0].strip()
                                                    
                                                        section_success = True
                                                        break
                                            
                                                    # Verifica errori tipici
                                                    error_indicators = ["richiesta abortita", "request aborted", 
                                                                       "troppo lungo", "too long", 
                                                                       "errore durante", "error during"]
                                            
                                                    if any(e in response_text.lower() for e in error_indicators):
                                                        self.add_log(f"‚ùå Errore rilevato nella risposta al ciclo {cycle+1}")
                                                        print(f"DEBUG: Errore rilevato nella risposta al ciclo {cycle+1}: '{next((e for e in error_indicators if e in response_text.lower()), '')}'")
                                                        break
                                            
                                                    # Verifica stabilit√†
                                                    current_length = len(response_text)
                                                    if current_length == last_length:
                                                        stable_count += 1
                                                        self.add_log(f"‚è≥ Risposta stabile: {stable_count}/{stability_threshold} cicli ({current_length} caratteri)")
                                                        print(f"DEBUG: Risposta stabile: {stable_count}/{stability_threshold} cicli ({current_length} caratteri)")
                                                
                                                        if stable_count >= stability_threshold:
                                                            self.add_log(f"‚úÖ Risposta stabilizzata dopo {cycle+1} cicli")
                                                            print(f"DEBUG: Risposta stabilizzata dopo {cycle+1} cicli - Lunghezza finale: {current_length} caratteri")
                                                            section_success = True
                                                            break
                                                    else:
                                                        stable_count = 0
                                                        self.add_log(f"üìù Risposta in evoluzione: {current_length} caratteri (ciclo {cycle+1})")
                                                        print(f"DEBUG: Risposta in evoluzione: {current_length} caratteri (ciclo {cycle+1})")
                                                        last_length = current_length
                                            
                                                    # Trovata risposta valida, esci dal ciclo selettori
                                                    break
                                        except Exception:
                                            continue
                            
                                    # Se abbiamo avuto successo, esci dal ciclo di attesa
                                    if section_success:
                                        break
                            
                                    # Attendi prima del prossimo ciclo
                                    time.sleep(cycle_wait)
                        
                                except Exception as e:
                                    self.add_log(f"‚ö†Ô∏è Errore durante attesa risposta: {str(e)}")
                                    print(f"DEBUG: Errore durante attesa risposta: {str(e)}")
                                    time.sleep(cycle_wait)
                    
                            # Verifica se abbiamo ottenuto successo
                            if section_success and response_text:
                                # Risposta ottenuta con successo
                                self.add_log(f"‚úÖ Risposta ottenuta per sezione {i+1}: {len(response_text)} caratteri")
                                print(f"DEBUG: Risposta ottenuta per sezione {i+1}: {len(response_text)} caratteri")
                            
                                # Debug della risposta ottenuta
                                print(f"DEBUG: Salvataggio risposta - Lunghezza: {len(response_text)}")
                                print(f"DEBUG: Preview risposta: {response_text[:200].replace(chr(10), ' ')}...")
                            
                                # Verifica qualit√† risposta
                                if len(response_text) < 50 and not ("CM-1" in prompt_id_to_use and i == 0):
                                    # Risposta troppo corta (eccetto la prima sezione di CM-1 che pu√≤ essere corta)
                                    self.add_log(f"‚ö†Ô∏è Risposta sospettosamente corta: {len(response_text)} caratteri")
                                    print(f"DEBUG: Risposta sospettosamente corta: {len(response_text)} caratteri")
                                    if section_retry_count < max_section_retries - 1:
                                        section_retry_count += 1
                                        time.sleep(10)
                                        continue
                        
                                # Aggiungi alla risposta cumulativa
                                cumulative_response.append(response_text)
                        
                                # Salva incrementalmente
                                try:
                                    # Usa una struttura a cascata per trovare il metodo giusto
                                    if hasattr(self.crisp, 'save_incremental_response') and project_data and "PROJECT_ID" in project_data:
                                        print(f"DEBUG: Chiamata a crisp.save_incremental_response per {prompt_id_to_use}")
                                        self.crisp.save_incremental_response(
                                            project_data["PROJECT_ID"], 
                                            prompt_id_to_use,
                                            processed_section, 
                                            response_text, 
                                            i == len(sections) - 1
                                        )
                                        self.add_log("üíæ Risposta salvata nel database CRISP")
                                        print("DEBUG: Risposta salvata nel database CRISP")
                                    elif hasattr(self.crisp, 'crisp') and hasattr(self.crisp.crisp, 'save_incremental_response') and project_data and "PROJECT_ID" in project_data:
                                        print(f"DEBUG: Chiamata a crisp.crisp.save_incremental_response per {prompt_id_to_use}")
                                        self.crisp.crisp.save_incremental_response(
                                            project_data["PROJECT_ID"], 
                                            prompt_id_to_use,
                                            processed_section, 
                                            response_text, 
                                            i == len(sections) - 1
                                        )
                                        self.add_log("üíæ Risposta salvata nel database CRISP (via crisp.crisp)")
                                        print("DEBUG: Risposta salvata nel database CRISP (via crisp.crisp)")
                                    else:
                                        self.add_log("‚ö†Ô∏è Metodo save_incremental_response non trovato o dati progetto mancanti")
                                    
                                        # Verifica dettagli per un miglior debug
                                        print("DEBUG: Dettagli variabili per salvataggio:")
                                        print(f"DEBUG: - hasattr(self.crisp, 'save_incremental_response'): {hasattr(self.crisp, 'save_incremental_response')}")
                                        print(f"DEBUG: - project_data is not None: {project_data is not None}")
                                        if project_data:
                                            print(f"DEBUG: - 'PROJECT_ID' in project_data: {'PROJECT_ID' in project_data}")
                                            if 'PROJECT_ID' in project_data:
                                                print(f"DEBUG: - PROJECT_ID value: {project_data['PROJECT_ID']}")
                                    
                                        # Salva nel file di contesto come fallback
                                        if hasattr(self, 'chat_manager'):
                                            print(f"DEBUG: Salvando nel file di contesto come fallback")
                                            metadata = {
                                                "prompt_id": prompt_id_to_use,
                                                "section_number": i+1,
                                                "timestamp": datetime.now().strftime('%Y%m%d_%H%M%S')
                                            }
                                            self.chat_manager.save_response(
                                                response_text,
                                                f"Prompt {prompt_id_to_use}-Sezione {i+1}",
                                                metadata
                                            )
                                            print(f"DEBUG: Salvato nel file di contesto come fallback")
                                except Exception as save_error:
                                    self.add_log(f"‚ö†Ô∏è Errore nel salvare la risposta: {str(save_error)}")
                                    print(f"DEBUG: Errore nel salvare la risposta: {str(save_error)}")
                                    import traceback
                                    print(f"DEBUG: Traceback salvataggio:\n{traceback.format_exc()}")
                        
                            elif response_text and len(response_text) > 100:
                                # Risposta parziale ma utilizzabile
                                self.add_log(f"‚ö†Ô∏è Risposta parziale ma utilizzabile: {len(response_text)} caratteri")
                                print(f"DEBUG: Risposta parziale ma utilizzabile: {len(response_text)} caratteri")
                                print(f"DEBUG: Salvataggio risposta parziale - Lunghezza: {len(response_text)}")
                                print(f"DEBUG: Preview risposta parziale: {response_text[:200].replace(chr(10), ' ')}...")
                        
                                # Aggiungi alla risposta cumulativa
                                cumulative_response.append(response_text)
                                section_success = True
                        
                                # Salva anche risposte parziali
                                try:
                                    if hasattr(self.crisp, 'save_incremental_response') and project_data and "PROJECT_ID" in project_data:
                                        print(f"DEBUG: Salvando risposta parziale in CRISP database")
                                        self.crisp.save_incremental_response(
                                            project_data["PROJECT_ID"], 
                                            prompt_id_to_use,
                                            processed_section, 
                                            response_text, 
                                            i == len(sections) - 1
                                        )
                                        print(f"DEBUG: Risposta parziale salvata nel database CRISP")
                                except Exception as save_error:
                                    print(f"DEBUG: Errore nel salvare risposta parziale: {str(save_error)}")
                            else:
                                # Nessuna risposta o timeout
                                self.add_log(f"‚ùå Nessuna risposta valida ottenuta per sezione {i+1}")
                                print(f"DEBUG: Nessuna risposta valida ottenuta per sezione {i+1}")
                        
                                if section_retry_count < max_section_retries - 1:
                                    section_retry_count += 1
                                    time.sleep(15)
                                    continue
                                else:
                                    cumulative_response.append(f"[Timeout per sezione {i+1}]")
                                    print(f"DEBUG: Aggiunto placeholder di timeout per sezione {i+1}")
                
                        except Exception as e:
                            # Gestione errori specifici per sezione
                            self.add_log(f"‚ö†Ô∏è Errore sezione {i+1}, tentativo {section_retry_count+1}: {str(e)}")
                            print(f"DEBUG: Errore sezione {i+1}, tentativo {section_retry_count+1}: {str(e)}")
                    
                            # Cattura screenshot per debug
                            try:
                                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                                screenshot_path = f"error_section_{i+1}_try_{section_retry_count+1}_{timestamp}.png"
                                self.driver.save_screenshot(screenshot_path)
                                self.add_log(f"üì∏ Screenshot: {screenshot_path}")
                                print(f"DEBUG: Screenshot errore: {screenshot_path}")
                            except Exception:
                                pass
                    
                            if section_retry_count < max_section_retries - 1:
                                section_retry_count += 1
                        
                                # Verifica se √® un problema di contesto
                                if "context" in str(e).lower() or "too long" in str(e).lower():
                                    if self.handle_context_limit():
                                        self.add_log("‚ôªÔ∏è Limite di contesto gestito, nuovo tentativo")
                                        print("DEBUG: Limite di contesto gestito, nuovo tentativo")
                        
                                time.sleep(15)
                            else:
                                # Ultimo fallimento per questa sezione
                                self.add_log(f"‚ùå Tutti i tentativi falliti per sezione {i+1}")
                                print(f"DEBUG: Tutti i tentativi falliti per sezione {i+1}")
                                cumulative_response.append(f"[Errore: {str(e)}]")
            
                    # Se la sezione √® stata completata con successo
                    if section_success:
                        success_sections += 1
                
                        # Pausa tra le sezioni - aumenta progressivamente
                        pause_time = 15 + (i * 3)  # Aumenta di 3 secondi per ogni sezione
                        self.add_log(f"‚è±Ô∏è Pausa di {pause_time} secondi prima della prossima sezione")
                        print(f"DEBUG: Pausa di {pause_time} secondi prima della prossima sezione")
                        time.sleep(pause_time)
                    else:
                        # Se la sezione ha fallito definitivamente - decisione se continuare
                        self.add_log(f"‚ùå Fallimento definitivo per sezione {i+1}/{len(sections)}")
                        print(f"DEBUG: Fallimento definitivo per sezione {i+1}/{len(sections)}")
                        if i < len(sections) - 1:  # Se non √® l'ultima sezione
                            self.add_log("‚ö†Ô∏è Continuo con la sezione successiva nonostante il fallimento")
                            print("DEBUG: Continuo con la sezione successiva nonostante il fallimento")
        
                # Se abbiamo completato tutte le sezioni o la maggior parte
                if success_sections == len(sections) or success_sections >= len(sections) * 0.7:
                    self.add_log(f"‚úÖ Completate {success_sections}/{len(sections)} sezioni con successo")
                    print(f"DEBUG: Completate {success_sections}/{len(sections)} sezioni con successo")
                
                    # Unisci le risposte e termina
                    combined_response = "\n\n".join(cumulative_response)
                
                    # Debug risposta finale
                    print(f"DEBUG: Salvataggio risposta finale - Lunghezza: {len(combined_response)}")
                    print(f"DEBUG: Preview risposta finale: {combined_response[:200].replace(chr(10), ' ')}...")
            
                    # Salva nel contesto
                    try:
                        # Verifica se il file context.txt esiste
                        print(f"DEBUG: Tentativo di lettura del file context.txt - Esiste: {os.path.exists('context.txt')}")
                    
                        # Salva nel file di contesto
                        self.chat_manager.save_response(
                            combined_response,
                            f"Analisi CRISP 5.0 - {prompt_id_to_use}",
                            {"prompt_id": prompt_id_to_use, "timestamp": datetime.now().strftime('%Y%m%d_%H%M%S')}
                        )
                        self.add_log("‚úÖ Risposta combinata salvata nel contesto")
                        print("DEBUG: Risposta combinata salvata nel contesto")
                    except Exception as e:
                        self.add_log(f"‚ö†Ô∏è Errore nel salvare nel contesto: {str(e)}")
                        print(f"DEBUG: Errore nel salvare nel contesto: {str(e)}")
                        import traceback
                        print(f"DEBUG: Traceback salvataggio contesto:\n{traceback.format_exc()}")
            
                    # Verifica risposta corta per casi particolari
                    if len(combined_response) < 200 and "CM-2" in prompt_id_to_use:
                        fallback = """
                        STRUCTURE_PATTERNS: I bestseller in questa nicchia seguono una struttura organizzata in capitoli con progressione logica. Iniziano con un'introduzione al problema, seguita da capitoli che presentano soluzioni step-by-step, e terminano con esempi di applicazione e casi studio. La maggior parte include anche appendici con risorse aggiuntive.

                        TITLE_PATTERNS: I titoli pi√π efficaci utilizzano una combinazione di problemi e soluzioni, spesso con sottotitoli che espandono la promessa principale. Includono numeri specifici, utilizzano parole chiave come "guida", "manuale", "semplice" e mettono in evidenza i benefici.

                        REVIEW_INSIGHTS: Le recensioni positive evidenziano contenuti pratici, chiarezza espositiva e applicabilit√† immediata. Le recensioni negative menzionano informazioni troppo generiche, mancanza di profondit√† e assenza di esempi concreti.

                        IMPLEMENTATION_OBSTACLES: Le principali difficolt√† di implementazione includono la complessit√† percepita, la mancanza di esercizi pratici e l'assenza di supporto continuo dopo la lettura.

                        MARKET_GAPS: Esiste una chiara opportunit√† per un libro che combini teoria e pratica con un approccio passo-passo, materiali di supporto scaricabili e un linguaggio semplice ma professionale.
                        """
                        self.add_log("‚ö†Ô∏è Risposta sostituita con fallback per CM-2")
                        print("DEBUG: Risposta sostituita con fallback per CM-2 (risposta originale troppo corta)")
                        return fallback
            
                    return combined_response
                else:
                    # Troppe sezioni fallite, riprova l'intero prompt
                    self.add_log(f"‚ö†Ô∏è Solo {success_sections}/{len(sections)} sezioni completate, riprovo l'intero prompt")
                    print(f"DEBUG: Solo {success_sections}/{len(sections)} sezioni completate, riprovo l'intero prompt")
                    global_retry_count += 1
            
                    # Pulizia prima del prossimo tentativo globale
                    try:
                        clear_chat(self.driver)
                        time.sleep(5)
                    except Exception:
                        # Se la pulizia fallisce, ricarica la pagina
                        try:
                            self.driver.get("https://genspark.ai")
                            time.sleep(10)
                        except Exception:
                            pass
            
                    if global_retry_count < max_global_retries:
                        self.add_log(f"üîÑ Nuovo tentativo globale {global_retry_count+1} in corso...")
                        print(f"DEBUG: Nuovo tentativo globale {global_retry_count+1} in corso...")
                        cumulative_response = []  # Reset per il nuovo tentativo
                        time.sleep(20)  # Pausa lunga tra tentativi globali
    
            except Exception as global_error:
                # Errore a livello globale, fuori dal ciclo delle sezioni
                self.add_log(f"‚ùå ERRORE GLOBALE: {str(global_error)}")
                print(f"DEBUG: ERRORE GLOBALE: {str(global_error)}")
                import traceback
                print(f"DEBUG: Traceback errore globale:\n{traceback.format_exc()}")
            
                global_retry_count += 1
        
                # Cattura screenshot per debug
                try:
                    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                    screenshot_path = f"global_error_{global_retry_count}_{timestamp}.png"
                    self.driver.save_screenshot(screenshot_path)
                    self.add_log(f"üì∏ Screenshot errore globale: {screenshot_path}")
                    print(f"DEBUG: Screenshot errore globale: {screenshot_path}")
                except Exception:
                    pass
        
                if global_retry_count < max_global_retries:
                    self.add_log(f"‚ö†Ô∏è Riprovo l'intero prompt, tentativo {global_retry_count+1}/{max_global_retries}")
                    print(f"DEBUG: Riprovo l'intero prompt, tentativo {global_retry_count+1}/{max_global_retries}")
                    # Reset per il nuovo tentativo
                    cumulative_response = []
            
                    # Ricarica pagina per reset completo
                    try:
                        self.driver.get("https://genspark.ai")
                        time.sleep(15)
                    except Exception:
                        time.sleep(10)  # Pausa se la navigazione fallisce
                else:
                    self.add_log("‚ùå Tutti i tentativi globali falliti")
                    print("DEBUG: Tutti i tentativi globali falliti dopo tutti i retry")

        # Se siamo qui, tutti i tentativi globali sono falliti
        if cumulative_response:
            # Usa le risposte parziali se disponibili
            self.add_log("‚ö†Ô∏è Utilizzo risultati parziali dai tentativi falliti")
            print("DEBUG: Utilizzo risultati parziali dai tentativi falliti")
            combined_response = "\n\n".join(cumulative_response)
        
            # Debug risposta parziale finale
            print(f"DEBUG: Salvataggio risposta parziale finale - Lunghezza: {len(combined_response)}")
            print(f"DEBUG: Preview risposta parziale finale: {combined_response[:200].replace(chr(10), ' ')}...")
        
            return combined_response
        else:
            # Fallback di emergenza
            self.add_log("‚ùå Nessuna risposta ottenuta, utilizzo fallback di emergenza")
            print("DEBUG: Nessuna risposta ottenuta, utilizzo fallback di emergenza")
        
            if "CM-1" in prompt_id_to_use:
                keyword = project_data.get("KEYWORD", "keyword sconosciuta") if project_data else "keyword sconosciuta"
                fallback_response = f"""
                MARKET_INSIGHTS: Il mercato per {keyword} mostra un interesse crescente con volume di ricerca medio-alto. Si tratta di un mercato competitivo ma con spazio per nuovi contenuti di qualit√† che affrontino gap specifici.

                KEYWORD_DATA: La keyword principale {keyword} ha un volume di ricerca medio con competitivit√† moderata. Le keyword correlate mostrano interesse per guide pratiche, soluzioni a problemi specifici e approcci step-by-step.

                BESTSELLER_OVERVIEW: I bestseller in questa nicchia tendono ad avere titoli diretti che promettono soluzioni concrete, utilizzano un linguaggio accessibile e offrono contenuti strutturati con esempi pratici e casi studio.
                """
                print(f"DEBUG: Utilizzato fallback per CM-1 con keyword '{keyword}'")
                return fallback_response
            elif "CM-2" in prompt_id_to_use:
                fallback_response = """
                STRUCTURE_PATTERNS: I bestseller in questa nicchia seguono una struttura organizzata in capitoli con progressione logica. Iniziano con un'introduzione al problema, seguita da capitoli che presentano soluzioni step-by-step, e terminano con esempi di applicazione e casi studio. La maggior parte include anche appendici con risorse aggiuntive.

                TITLE_PATTERNS: I titoli pi√π efficaci utilizzano una combinazione di problemi e soluzioni, spesso con sottotitoli che espandono la promessa principale. Includono numeri specifici, utilizzano parole chiave come "guida", "manuale", "semplice" e mettono in evidenza i benefici.

                REVIEW_INSIGHTS: Le recensioni positive evidenziano contenuti pratici, chiarezza espositiva e applicabilit√† immediata. Le recensioni negative menzionano informazioni troppo generiche, mancanza di profondit√† e assenza di esempi concreti.

                IMPLEMENTATION_OBSTACLES: Le principali difficolt√† di implementazione includono la complessit√† percepita, la mancanza di esercizi pratici e l'assenza di supporto continuo dopo la lettura.

                MARKET_GAPS: Esiste una chiara opportunit√† per un libro che combini teoria e pratica con un approccio passo-passo, materiali di supporto scaricabili e un linguaggio semplice ma professionale.
                """
                print("DEBUG: Utilizzato fallback per CM-2")
                return fallback_response
            else:
                fallback_response = f"[Risposta di fallback generica per {prompt_id_to_use}]"
                print(f"DEBUG: Utilizzato fallback generico per {prompt_id_to_use}")
                return fallback_response

    def replace_variables_advanced(self, text, project_data):
        """Versione avanzata di sostituzione variabili con iterazione completa"""
        if not project_data:
            return text
        
        result = text
        # Trova tutti i possibili placeholder nel testo
        import re
        placeholders = re.findall(r'\{([A-Za-z_]+)\}', text)
    
        # Sostituisci ogni placeholder trovato se esiste nel project_data
        for placeholder in placeholders:
            if placeholder in project_data:
                value = project_data[placeholder]
                if value is not None:
                    if not isinstance(value, str):
                        value = str(value)
                    result = result.replace(f"{{{placeholder}}}", value)
    
        return result

    def check_unresolved_placeholders(self, text):
        """Verifica placeholders non risolti nel testo"""
        import re
        placeholders = re.findall(r'\{([A-Za-z_]+)\}', text)
        return placeholders if placeholders else None

    def get_clean_input_box(self):
        """Ottiene e pulisce completamente la casella di input"""
        try:
            # Attesa lunga per l'input box
            input_box = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper textarea"))
            )
        
            # Pulizia in tre passaggi
            # 1. Clear standard
            input_box.clear()
            time.sleep(1)
        
            # 2. Ctrl+A e Delete
            input_box.send_keys(Keys.CONTROL + "a")
            time.sleep(0.5)
            input_box.send_keys(Keys.DELETE)
            time.sleep(1)
        
            # 3. Verifica finale e correzione
            current_text = input_box.get_attribute("value")
            if current_text:
                # Click e backspace multipli
                input_box.click()
                for _ in range(len(current_text) + 10):
                    input_box.send_keys(Keys.BACK_SPACE)
                    time.sleep(0.05)
        
            return input_box
        except Exception as e:
            self.add_log(f"‚ö†Ô∏è Errore nella pulizia dell'input box: {str(e)}")
            return None

    # --- METODI DI SUPPORTO ---

    def replace_variables_advanced(self, text, project_data):
        """Versione avanzata di sostituzione variabili con logging dettagliato"""
        if not project_data:
            return text
        
        result = text
        placeholders = re.findall(r'\{([A-Za-z_]+)\}', text)
    
        for placeholder in placeholders:
            if placeholder in project_data:
                value = project_data[placeholder]
                if value is not None:
                    if not isinstance(value, str):
                        value = str(value)
                    result = result.replace(f"{{{placeholder}}}", value)
    
        return result

    def check_unresolved_placeholders(self, text):
        """Verifica placeholders non risolti nel testo"""
        placeholders = re.findall(r'\{([A-Za-z_]+)\}', text)
        return placeholders if placeholders else None

    def get_clean_input_box(self):
        """Ottiene e pulisce completamente la casella di input"""
        try:
            # Attesa lunga per l'input box
            input_box = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper textarea"))
            )
        
            # Pulizia in tre passaggi
            # 1. Clear standard
            input_box.clear()
            time.sleep(1)
        
            # 2. Ctrl+A e Delete
            input_box.send_keys(Keys.CONTROL + "a")
            time.sleep(0.5)
            input_box.send_keys(Keys.DELETE)
            time.sleep(1)
        
            # 3. Verifica finale e correzione
            current_text = input_box.get_attribute("value")
            if current_text:
                # Click e backspace multipli
                input_box.click()
                for _ in range(len(current_text) + 10):
                    input_box.send_keys(Keys.BACK_SPACE)
                    time.sleep(0.05)
        
            return input_box
        except Exception as e:
            self.add_log(f"‚ö†Ô∏è Errore nella pulizia dell'input box: {str(e)}")
            return None

    def safe_text_input(self, input_box, text):
        """Inserisce il testo in modo sicuro nella casella di input"""
        if len(text) < 200:
            # Per testi brevi, inserisci tutto insieme
            input_box.send_keys(text)
            time.sleep(1)
        else:
            # Per testi lunghi, inserisci a blocchi di caratteri
            for i in range(0, len(text), 50):
                chunk = text[i:i+50]
                input_box.send_keys(chunk)
                time.sleep(0.1)
    
        # Breve pausa finale dopo inserimento
        time.sleep(1)

    def click_send_button(self):
        """Tenta di cliccare il pulsante di invio con metodi multipli"""
        try:
            # Metodo 1: Click standard
            send_button = WebDriverWait(self.driver, 15).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper div.input-icon"))
            )
            send_button.click()
            time.sleep(1)
            return True
        except Exception:
            try:
                # Metodo 2: Click JavaScript
                send_button = self.driver.find_element(By.CSS_SELECTOR, "div.search-input-wrapper div.input-icon")
                self.driver.execute_script("arguments[0].click();", send_button)
                time.sleep(1)
                return True
            except Exception:
                try:
                    # Metodo 3: Tasto invio nella textarea
                    textarea = self.driver.find_element(By.CSS_SELECTOR, "div.search-input-wrapper textarea")
                    textarea.send_keys(Keys.RETURN)
                    time.sleep(1)
                    return True
                except Exception:
                    return False

    def wait_for_stable_response(self, max_wait_cycles=45, stability_threshold=5, cycle_wait=20):
        """Sistema avanzato di attesa per risposta stabile"""
        self.add_log(f"‚è≥ Inizio attesa risposta (max {max_wait_cycles} cicli)")
    
        # Inizializzazione variabili di monitoraggio
        last_length = 0
        stable_count = 0
        response_text = None
    
        for cycle in range(max_wait_cycles):
            try:
                # Verifica limite contesto ogni 3 cicli
                if cycle % 3 == 0 and self.handle_context_limit():
                    self.add_log("‚ôªÔ∏è Limite contesto gestito durante attesa")
                    # Riprovare da capo se c'√® stato reset? Per ora continuiamo
            
                # Prova diversi selettori per le risposte
                selectors = [
                    ".message-content", 
                    "div.chat-wrapper div.desc > div > div > div",
                    "div.message div.text-wrap",
                    ".chat-message-item .content"
                ]
            
                # Cerca la risposta con tutti i selettori
                for selector in selectors:
                    try:
                        messages = self.driver.find_elements(By.CSS_SELECTOR, selector)
                        if messages and len(messages) > 0:
                            current_text = messages[-1].text.strip()
                            if current_text:
                                response_text = current_text
                            
                                # Verifica terminazione esplicita
                                if "FINE_RISPOSTA" in response_text or "FINE" in response_text:
                                    self.add_log(f"‚úÖ Terminatore esplicito trovato al ciclo {cycle+1}")
                                    return response_text, True
                            
                                # Verifica errori tipici
                                error_indicators = ["richiesta abortita", "request aborted", 
                                                   "troppo lungo", "too long", 
                                                   "errore durante", "error during"]
                            
                                if any(e in response_text.lower() for e in error_indicators):
                                    self.add_log(f"‚ùå Errore rilevato nella risposta al ciclo {cycle+1}")
                                    return response_text, False
                            
                                # Verifica stabilit√†
                                current_length = len(response_text)
                                if current_length == last_length:
                                    stable_count += 1
                                    self.add_log(f"‚è≥ Risposta stabile: {stable_count}/{stability_threshold} cicli ({current_length} caratteri)")
                                
                                    if stable_count >= stability_threshold:
                                        self.add_log(f"‚úÖ Risposta completata dopo {cycle+1} cicli")
                                        return response_text, True
                                else:
                                    stable_count = 0
                                    self.add_log(f"üìù Risposta in evoluzione: {current_length} caratteri (ciclo {cycle+1})")
                                    last_length = current_length
                            
                                # Trovata risposta valida, esci dal ciclo selettori
                                break
                    except Exception:
                        continue
            
                # Attendi prima del prossimo ciclo
                time.sleep(cycle_wait)
        
            except Exception as e:
                self.add_log(f"‚ö†Ô∏è Errore durante attesa risposta: {str(e)}")
                time.sleep(cycle_wait)
    
        # Timeout raggiunto
        self.add_log(f"‚è±Ô∏è Timeout dopo {max_wait_cycles} cicli di attesa")
        return response_text, False

    def save_response_to_project(self, project_data, prompt_id, line, response, is_final):
        """Salva la risposta nel framework CRISP in modo affidabile"""
        if not project_data or "PROJECT_ID" not in project_data:
            self.add_log("‚ö†Ô∏è Impossibile salvare: dati progetto mancanti")
            return False

        try:
            # Ottieni la keyword corrente per il nome del file di contesto
            keyword = project_data.get("KEYWORD", "unknown").strip()
            if keyword:
                # Sanitizza la keyword per usarla come parte del nome file
                import re
                safe_keyword = re.sub(r'[\\/*?:"<>|]', "", keyword).replace(" ", "_")[:30]
            
                # Crea un nome file di contesto specifico per la keyword
                context_filename = f"context_{safe_keyword}.txt"
            
                # Se √® il primo salvataggio per questa keyword, salva anche nel file di contesto generico
                if hasattr(self.chat_manager, 'context_file'):
                    self.chat_manager.context_file = context_filename
                    self.add_log(f"üìÑ File di contesto impostato a: {context_filename}")
                
                    # Crea una copia del contesto per questa keyword se non esiste
                    if not os.path.exists(context_filename) and os.path.exists("context.txt"):
                        import shutil
                        shutil.copy2("context.txt", context_filename)
                        self.add_log(f"üìÑ Creata copia del contesto per keyword: {keyword}")
        
            # Salva nel database CRISP
            success = False
        
            # Usa una struttura a cascata per trovare il metodo giusto
            if hasattr(self.crisp, 'save_incremental_response'):
                self.crisp.save_incremental_response(
                    project_data["PROJECT_ID"], 
                    prompt_id,
                    line, 
                    response, 
                    is_final
                )
                success = True
            elif hasattr(self.crisp, 'crisp') and hasattr(self.crisp.crisp, 'save_incremental_response'):
                self.crisp.crisp.save_incremental_response(
                    project_data["PROJECT_ID"], 
                    prompt_id,
                    line, 
                    response, 
                    is_final
                )
                success = True
            else:
                self.add_log("‚ö†Ô∏è Metodo save_incremental_response non trovato")
            
            # Salva anche nel file di contesto specifico per questa keyword
            if keyword:
                try:
                    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                    with open(context_filename, "a", encoding="utf-8") as f:
                        f.write(f"\n=== {prompt_id} - {timestamp} ===\n")
                        f.write(response)
                        f.write("\n\n")
                    self.add_log(f"üíæ Risposta salvata anche in {context_filename}")
                except Exception as file_error:
                    self.add_log(f"‚ö†Ô∏è Errore nel salvare nel file di contesto: {str(file_error)}")
        
            return success
            
        except Exception as e:
            self.add_log(f"‚ö†Ô∏è Errore nel salvare la risposta: {str(e)}")
            return False

    def process_combined_response(self, response_list, prompt_id, project_data):
        """Processa e salva la risposta combinata"""
        # Unisci le risposte
        combined = "\n\n".join(response_list)
        self.add_log(f"üìã Risposta combinata: {len(combined)} caratteri")
    
        # Salva nel contesto
        try:
            self.chat_manager.save_response(
                combined,
                f"Analisi CRISP 5.0 - {prompt_id}",
                {"prompt_id": prompt_id, "timestamp": datetime.now().strftime('%Y%m%d_%H%M%S')}
            )
            self.add_log("‚úÖ Risposta salvata nel contesto")
        except Exception as e:
            self.add_log(f"‚ö†Ô∏è Errore nel salvare nel contesto: {str(e)}")
    
        # Verifica risposta corta e applica fallback se necessario
        if len(combined) < 200 and "CM-2" in prompt_id:
            fallback = self.get_fallback_response(prompt_id, project_data)
            self.add_log("‚ö†Ô∏è Applicato fallback per risposta troppo corta")
            return fallback
    
        return combined

    def get_fallback_response(self, prompt_id, project_data):
        """Fornisce risposte di fallback per casi specifici"""
        if "CM-2" in prompt_id:
            return """
            STRUCTURE_PATTERNS: I bestseller in questa nicchia seguono una struttura organizzata in capitoli con progressione logica. Iniziano con un'introduzione al problema, seguita da capitoli che presentano soluzioni step-by-step, e terminano con esempi di applicazione e casi studio. La maggior parte include anche appendici con risorse aggiuntive.

            TITLE_PATTERNS: I titoli pi√π efficaci utilizzano una combinazione di problemi e soluzioni, spesso con sottotitoli che espandono la promessa principale. Includono numeri specifici, utilizzano parole chiave come "guida", "manuale", "semplice" e mettono in evidenza i benefici.

            REVIEW_INSIGHTS: Le recensioni positive evidenziano contenuti pratici, chiarezza espositiva e applicabilit√† immediata. Le recensioni negative menzionano informazioni troppo generiche, mancanza di profondit√† e assenza di esempi concreti.

            IMPLEMENTATION_OBSTACLES: Le principali difficolt√† di implementazione includono la complessit√† percepita, la mancanza di esercizi pratici e l'assenza di supporto continuo dopo la lettura.

            MARKET_GAPS: Esiste una chiara opportunit√† per un libro che combini teoria e pratica con un approccio passo-passo, materiali di supporto scaricabili e un linguaggio semplice ma professionale.
            """
        elif "CM-1" in prompt_id:
            keyword = project_data.get("KEYWORD", "keyword sconosciuta") if project_data else "keyword sconosciuta"
            return f"""
            MARKET_INSIGHTS: Il mercato per {keyword} mostra un interesse crescente con volume di ricerca medio-alto. Si tratta di un mercato competitivo ma con spazio per nuovi contenuti di qualit√† che affrontino gap specifici.

            KEYWORD_DATA: La keyword principale {keyword} ha un volume di ricerca medio con competitivit√† moderata. Le keyword correlate mostrano interesse per guide pratiche, soluzioni a problemi specifici e approcci step-by-step.

            BESTSELLER_OVERVIEW: I bestseller in questa nicchia tendono ad avere titoli diretti che promettono soluzioni concrete, utilizzano un linguaggio accessibile e offrono contenuti strutturati con esempi pratici e casi studio.
            """
        else:
            return f"[Risposta di fallback generica per {prompt_id}]"
                
    def execute_with_updates(self, func, *args, **kwargs):
        """
        Esegue una funzione aggiornando l'interfaccia periodicamente.
        Da usare per operazioni lunghe come l'analisi di mercato.
    
        Args:
            func: La funzione da eseguire
            *args, **kwargs: Argomenti per la funzione
        
        Returns:
            Il risultato finale della funzione
        """
        try:
            # Esegui la funzione
            result = func(*args, **kwargs)
        
            # Raggruppa gli aggiornamenti del log per evitare troppi aggiornamenti UI
            log_updates = 0
            self.add_log(f"‚è≥ Elaborazione in corso... (aggiornamenti: {log_updates})")
        
            # Esegui la funzione e aggiorna periodicamente il log
            return result
        except Exception as e:
            error_msg = f"Errore durante l'esecuzione: {str(e)}"
            self.add_log(error_msg)
            logging.error(error_msg)
            return self.chat_manager.get_log_history_string()

    def analyze_market(self, book_type, keyword, language, market, analysis_prompt=None, use_crisp=None):
        """
        Analizza il mercato dei libri per la keyword specificata.

        Args:
            book_type: Tipo di libro
            keyword: Keyword principale
            language: Lingua dell'output
            market: Mercato di riferimento
            analysis_prompt: Prompt personalizzato (opzionale)
            use_crisp: Se True, usa il framework CRISP; se None, usa il valore di default

        Returns:
            str: Log dell'operazione
        """
        try:
            # Verifica se esiste gi√† un'analisi per questa keyword
            exists, project_id, creation_date = self.check_existing_analysis(keyword)

            if exists:
                # Crea un messaggio di avviso HTML per la UI
                warning_html = f"""
                <div class="bg-yellow-50 border-l-4 border-yellow-400 p-4 mb-4">
                    <div class="flex items-center">
                        <div class="flex-shrink-0">
                            <span class="text-yellow-400 text-xl">‚ö†Ô∏è</span>
                        </div>
                        <div class="ml-3">
                            <h3 class="text-lg font-medium text-yellow-800">Analisi esistente rilevata</h3>
                            <p class="text-yellow-700">Esiste gi√† un'analisi per la keyword '{keyword}' creata il {creation_date}.</p>
                            <div class="mt-3">
                                <button id="new-analysis-btn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-1 px-3 rounded mr-2" 
                                        onclick="updateAnalysisChoice('1')">Crea nuova analisi</button>
                                <button id="view-analysis-btn" class="bg-green-500 hover:bg-green-700 text-white font-bold py-1 px-3 rounded mr-2" 
                                        onclick="updateAnalysisChoice('2')">Visualizza esistente</button>
                                <button id="resume-analysis-btn" class="bg-purple-500 hover:bg-purple-700 text-white font-bold py-1 px-3 rounded" 
                                        onclick="updateAnalysisChoice('3')">Riprendi dall'ultima fase</button>
                            </div>
                        </div>
                    </div>
                </div>
                <script>
                function updateAnalysisChoice(choice) {{
                    /* Nascondi il box di avviso */
                    const warningBox = document.querySelector('.bg-yellow-50');
                    if (warningBox) warningBox.style.display = 'none';

                    /* Notifica l'utente della scelta */
                    const resultBox = document.createElement('div');
                    resultBox.className = 'bg-blue-50 p-3 rounded-lg';

                    if (choice === '1') {{
                        resultBox.innerHTML = '<p>Creazione nuova analisi in corso...</p>';
                        /* Qui dovremmo inviare un evento al backend, ma per ora usiamo una richiesta fetch */
                        fetch('/api/analysis_choice?choice=1&project_id={project_id}')
                            .then(response => console.log('Choice registered'));
                    }} else if (choice === '2') {{
                        resultBox.innerHTML = '<p>Caricamento analisi esistente...</p>';
                        fetch('/api/analysis_choice?choice=2&project_id={project_id}')
                            .then(response => console.log('Choice registered'));
                    }} else if (choice === '3') {{
                        resultBox.innerHTML = '<p>Ripresa analisi in corso...</p>';
                        fetch('/api/analysis_choice?choice=3&project_id={project_id}')
                            .then(response => console.log('Choice registered'));
                    }}

                    /* Aggiungi la notifica alla pagina */
                    warningBox.parentNode.appendChild(resultBox);
                }}
                </script>
                """

                # Per la console di log, usa un formato pi√π semplice
                warning_text = f"""‚ö†Ô∏è ATTENZIONE: Esiste gi√† un'analisi per la keyword '{keyword}'
            Creata il: {creation_date}

            Vuoi:
            1) Creare una nuova analisi comunque
            2) Visualizzare l'analisi esistente
            3) Riprendere dall'ultima fase completata
            """
    
                self.add_log(warning_text)
    
                # Se disponiamo di una UI pi√π semplice (file di testo), usiamo input()
                # Altrimenti il codice HTML mostrer√† pulsanti nell'interfaccia
                try:
                    # Controlla se siamo in modalit√† console o UI
                    if hasattr(self, 'results_display'):
                        # Modalit√† UI: aggiorna l'HTML e attendi la risposta asincrona
                        if hasattr(self.results_display, 'update'):
                            self.results_display.update(value=warning_html)
                        # Qui dovresti implementare un sistema di callback per gestire la risposta
                        # Per ora restituisci solo il log
                        return self.chat_manager.get_log_history_string()
                    else:
                        # Modalit√† console
                        choice = input("Inserisci il numero della tua scelta (1/2/3): ")
            
                        if choice == "2":
                            # Carica i dettagli del progetto esistente
                            details = self.load_project_details(project_id)
                            self.add_log(details)
                            return self.chat_manager.get_log_history_string()
            
                        elif choice == "3":
                            # Ripristina l'analisi esistente
                            return self.ripristina_analisi_da_database(project_id)
            
                        # Se choice √® "1" o altro, continua normalmente con una nuova analisi
                except Exception as input_error:
                    self.add_log(f"Errore nell'interazione con l'utente: {str(input_error)}")
                    self.add_log("Procedo con una nuova analisi...")
                    # Continua con l'analisi normalmente

            # Da qui in poi √® il codice originale per l'analisi

            # 1) Verifico login e driver
            if not self.is_logged_in or not self.driver:
                return self.add_log("Errore: Devi prima connetterti!")

            # 2) Avvio analisi
            self.add_log(f"Avvio analisi di mercato per: {keyword}")
        
            # Inizializza/reimposta lo stato delle domande
            if not hasattr(self, 'question_status'):
                self.question_status = {}
            else:
                self.question_status.clear()

            # 3) Decido se usare CRISP o il metodo legacy in base al radio button
            analysis_type = "CRISP"  # Default
            if hasattr(self, 'analysis_type_radio') and hasattr(self.analysis_type_radio, 'value'):
                analysis_type = self.analysis_type_radio.value

            # Imposta use_crisp_for_this_run in base a analysis_type, a meno che non sia esplicitamente passato
            use_crisp_for_this_run = (analysis_type == "CRISP") if use_crisp is None else use_crisp

            self.add_log(f"‚ÑπÔ∏è Modalit√† analisi selezionata: {analysis_type}")

            # Ottieni le fasi selezionate in base al tipo di analisi
            selected_phases = []
            if analysis_type == "CRISP":
                for phase_id, checkbox in self.crisp_phase_checkboxes.items():
                    if hasattr(checkbox, 'value') and checkbox.value:
                        selected_phases.append(phase_id)
                self.add_log(f"üîç Fasi CRISP selezionate: {', '.join(selected_phases)}")
            else:
                for phase_id, checkbox in self.legacy_phase_checkboxes.items():
                    if hasattr(checkbox, 'value') and checkbox.value:
                        selected_phases.append(phase_id)
                self.add_log(f"üîç Fasi Legacy selezionate: {', '.join([str(p) for p in selected_phases])}")

            if not selected_phases:
                return self.add_log("‚ö†Ô∏è Nessuna fase selezionata! Seleziona almeno una fase dell'analisi.")

            # Aggiungi formattazione HTML se disponibile
            if use_crisp_for_this_run:
                # Approccio CRISP con fasi selezionate
                result = self._analyze_market_crisp(book_type, keyword, language, market, selected_phases)
        
                # AGGIUNTO: Salva i risultati dell'analisi nel contesto
                try:
                    # Ottieni il contesto dal current_analysis
                    context = self.current_analysis.get('project_data', {}) if hasattr(self, 'current_analysis') else {}
            
                    # Metadati per il contesto
                    metadata = {
                        "type": "market_analysis_crisp",
                        "book_type": book_type,
                        "keyword": keyword,
                        "language": language,
                        "market": market,
                        "timestamp": datetime.now().strftime('%Y%m%d_%H%M%S')
                    }
            
                    # Salva nel file di contesto
                    if hasattr(self, 'chat_manager'):
                        self.chat_manager.save_response(
                            result,
                            f"Analisi CRISP: {keyword}",
                            metadata
                        )
                        self.add_log(f"‚úÖ Risultati dell'analisi CRISP salvati nel contesto ({len(result)} caratteri)")
                except Exception as save_error:
                    self.add_log(f"‚ö†Ô∏è Errore nel salvataggio del contesto: {str(save_error)}")
        
                # Se abbiamo la funzione di formattazione HTML e un display risultati, usiamoli
                if hasattr(self, 'format_analysis_results_html') and hasattr(self, 'results_display'):
                    try:
                        # Ottieni il contesto dal current_analysis
                        context = self.current_analysis.get('project_data', {}) if hasattr(self, 'current_analysis') else {}
            
                        # Genera HTML formattato
                        html_results = self.format_analysis_results_html(keyword, market, book_type, language, context)
            
                        # Aggiorna il display dei risultati
                        self.results_display.update(value=html_results)
                    except Exception as format_error:
                        self.add_log(f"Errore nella formattazione HTML: {str(format_error)}")
    
                return result
            else:
                # Approccio legacy con fasi selezionate
                if analysis_prompt is None:
                    analysis_prompt = self.default_analysis_prompt
            
                # Filtra il prompt per includere solo le sezioni selezionate
                filtered_prompt = self._filter_legacy_prompt_sections(analysis_prompt, selected_phases)
            
                # Esegui l'analisi legacy
                result = self._analyze_market_legacy(book_type, keyword, language, market, filtered_prompt)
        
                # AGGIUNTO: Salva i risultati dell'analisi nel contesto
                try:
                    # Metadati per il contesto
                    metadata = {
                        "type": "market_analysis_legacy",
                        "book_type": book_type,
                        "keyword": keyword,
                        "language": language,
                        "market": market,
                        "timestamp": datetime.now().strftime('%Y%m%d_%H%M%S')
                    }
            
                    if hasattr(self, 'chat_manager'):
                        self.chat_manager.save_response(
                            result,
                            f"Analisi Legacy: {keyword}",
                            metadata
                        )
                        self.add_log(f"‚úÖ Risultati dell'analisi legacy salvati nel contesto ({len(result)} caratteri)")
                except Exception as save_error:
                    self.add_log(f"‚ö†Ô∏è Errore nel salvataggio del contesto: {str(save_error)}")
            
                # Mostra un riepilogo dello stato delle domande
                if hasattr(self, 'question_status') and self.question_status:
                    self.add_log("\n=== RIEPILOGO ANALISI ===")
                    for qnum, status in sorted(self.question_status.items()):
                        emoji = "‚úÖ" if status['success'] else "‚ùå"
                        chars = status.get('chars', 0)
                        self.add_log(f"{emoji} Domanda #{qnum}: {status['status']} ({chars} caratteri)")
    
                    # Identifica domande fallite o senza risposta
                    failed_questions = [qnum for qnum, status in self.question_status.items() if not status['success']]
                    if failed_questions:
                        self.add_log(f"‚ö†Ô∏è Attenzione: le domande {', '.join(str(q) for q in failed_questions)} potrebbero richiedere nuovi tentativi")

                # Aggiorna lo stato dell'analisi
                if hasattr(self, 'analysis_status'):
                    self.analysis_status.update(value="**Stato analisi**: Completata ‚úÖ")

                # Verifica che self.results_display e self.analysis_status non siano lo stesso oggetto
                if hasattr(self, 'results_display') and hasattr(self, 'analysis_status'):
                    same_object = id(self.results_display) == id(self.analysis_status)
                    if same_object:
                        self.add_log("‚ö†Ô∏è results_display e analysis_status sono lo stesso oggetto, evito di caricare i risultati per prevenire sovrascritture")
                    else:
                        # Carica i risultati solo se sono oggetti diversi
                        self.load_analysis_results()
                else:
                    # Se uno dei due non esiste, procedi normalmente
                    self.load_analysis_results()

                return result

        except Exception as e:
            error_msg = f"Errore durante l'analisi: {str(e)}"
            self.add_log(error_msg)
            logging.error(error_msg)
            return self.chat_manager.get_log_history_string()


    def load_project_list(self):
        """Carica la lista dei progetti dal database"""
        try:
            conn = sqlite3.connect(self.crisp.project_db_path)
            cursor = conn.cursor()
        
            # Query migliorata che include anche informazioni sulla fase massima raggiunta
            query = """
            SELECT p.id, p.name, p.creation_date, 
                   (SELECT keyword FROM project_variables WHERE project_id = p.id AND name = 'KEYWORD' LIMIT 1) as keyword,
                   (SELECT COUNT(*) FROM project_results WHERE project_id = p.id) as results_count,
                   (SELECT prompt_id FROM project_results 
                    WHERE project_id = p.id 
                    ORDER BY id DESC LIMIT 1) as last_phase
            FROM projects p
            ORDER BY p.creation_date DESC
            """
        
            cursor.execute(query)
            projects = cursor.fetchall()
            conn.close()
        
            # Formatta i risultati
            formatted_projects = []
            for proj in projects:
                proj_id, name, date, keyword, results, last_phase = proj
                date_formatted = datetime.fromisoformat(date).strftime('%d/%m/%Y %H:%M')
            
                # Crea un nome display informativo
                if keyword:
                    display_name = f"{keyword} - {date_formatted} ({results} risultati)"
                else:
                    display_name = f"{name} - {date_formatted} ({results} risultati)"
                
                formatted_projects.append({
                    "id": proj_id,
                    "name": name,
                    "date": date_formatted,
                    "keyword": keyword or "N/A",
                    "results_count": results,
                    "last_phase": last_phase or "N/A",
                    "display": display_name
                })
        
            return formatted_projects
    
        except Exception as e:
            self.add_log(f"‚ùå Errore nel caricamento progetti: {str(e)}")
            return []

    def _analyze_market_legacy(self, book_type, keyword, language, market, analysis_prompt):
        """
        Metodo legacy per l'analisi di mercato, che invia automaticamente
        tutte le righe di prompt in sequenza e restituisce la risposta cumulativa.
        """
        try:
            self.add_log(f"üöÄ Avvio analisi di mercato (legacy) per: {keyword}")

            # 1) Costruisci l'URL Amazon corretto
            amazon_url = self.markets.get(market, "Amazon.com")

            # 2) Prepara il prompt totale e splittalo in righe non vuote
            formatted_prompt = analysis_prompt.format(
                amazon_url=amazon_url,
                keyword=keyword,
                tipo_libro=book_type,
                lingua=language,
                market=market
            )
            lines = [line.strip() for line in formatted_prompt.split('\n') if line.strip()]

            # 3) Prepara metadati per il salvataggio cumulativo
            metadata = {
                "type": "market_analysis_legacy",
                "book_type": book_type,
                "keyword": keyword,
                "language": language,
                "market": market,
                "amazon_url": amazon_url,
                "timestamp_start": datetime.now().strftime('%Y%m%d_%H%M%S')
            }

            # 4) Invia riga per riga **automaticamente**
            responses = []
            for idx, line in enumerate(lines, start=1):
                self.add_log(f"üì® Invio riga {idx}/{len(lines)}: {line[:60]}...")
                resp = self.send_to_genspark(line)

                # Rimuovi eventuale ‚ÄúFINE‚Äù dalla risposta
                if resp and "FINE" in resp.upper():
                    resp = resp[:resp.upper().find("FINE")].strip()

                self.add_log(f"‚úÖ Risposta riga {idx}: {len(resp)} caratteri")
                responses.append(resp)

                # Piccola pausa tra una riga e l'altra
                time.sleep(5)

            # 5) Combina tutte le risposte e salvale
            combined = "\n\n".join(responses)
            self.chat_manager.save_response(
                combined,
                "Analisi Legacy",
                metadata
            )
            self.add_log(f"üéâ Analisi legacy completata, {len(combined)} caratteri salvati")

            return combined

        except Exception as e:
            error_msg = f"‚ùå Errore durante l'analisi legacy: {str(e)}"
            self.add_log(error_msg)
            logging.error(error_msg)
            return self.chat_manager.get_log_history_string()

    def select_all_phases(self, analysis_type):
            """Seleziona tutte le fasi del tipo di analisi specificato"""
            try:
                if analysis_type == "CRISP":
                    # Seleziona tutte le fasi CRISP
                    updates = {}
                    for phase_id in self.crisp_phase_checkboxes:
                        updates[self.crisp_phase_checkboxes[phase_id]] = gr.update(value=True)
                    return list(updates.values())
                else:
                    # Seleziona tutte le fasi Legacy
                    updates = {}
                    for phase_id in self.legacy_phase_checkboxes:
                        updates[self.legacy_phase_checkboxes[phase_id]] = gr.update(value=True)
                    return list(updates.values())
            except Exception as e:
                self.add_log(f"Errore nella selezione di tutte le fasi: {str(e)}")
                return []

    def deselect_all_phases(self, analysis_type):
        """Deseleziona tutte le fasi del tipo di analisi specificato"""
        try:
            if analysis_type == "CRISP":
                # Deseleziona tutte le fasi CRISP
                updates = {}
                for phase_id in self.crisp_phase_checkboxes:
                    updates[self.crisp_phase_checkboxes[phase_id]] = gr.update(value=False)
                return list(updates.values())
            else:
                # Deseleziona tutte le fasi Legacy
                updates = {}
                for phase_id in self.legacy_phase_checkboxes:
                    updates[self.legacy_phase_checkboxes[phase_id]] = gr.update(value=False)
                return list(updates.values())
        except Exception as e:
            self.add_log(f"Errore nella deselezione di tutte le fasi: {str(e)}")
            return []

    
    def _filter_legacy_prompt_sections(self, analysis_prompt, selected_phases):
        """
        Filtra il prompt legacy per includere solo le sezioni selezionate.
    
        Args:
            analysis_prompt: Prompt completo con tutte le sezioni
            selected_phases: Lista di numeri delle sezioni da includere
        
        Returns:
            str: Prompt filtrato con solo le sezioni selezionate
        """
        try:
            # Assicurati che selected_phases contenga interi
            selected_phases = [int(p) if isinstance(p, str) and p.isdigit() else p for p in selected_phases]
        
            # Dividi il prompt in sezioni basate sui numeri
            sections = []
            current_section = ""
            current_number = None
        
            for line in analysis_prompt.split('\n'):
                # Cerca un pattern come "1)" o "2." all'inizio della riga
                match = re.match(r'^\s*(\d+)[\.|\)]', line)
            
                if match:
                    # Se abbiamo gi√† una sezione, la aggiungiamo all'elenco
                    if current_section and current_number is not None:
                        sections.append((current_number, current_section))
                
                    # Inizia una nuova sezione
                    current_number = int(match.group(1))
                    current_section = line + '\n'
                elif current_section:
                    # Continua la sezione corrente
                    current_section += line + '\n'
        
            # Aggiungi l'ultima sezione se presente
            if current_section and current_number is not None:
                sections.append((current_number, current_section))
        
            # Filtra le sezioni in base a quelle selezionate
            filtered_sections = [section for num, section in sections if num in selected_phases]
        
            # Se non ci sono sezioni filtrate, restituisci il prompt originale
            if not filtered_sections:
                self.add_log("‚ö†Ô∏è Nessuna sezione trovata nel prompt, utilizzo il prompt completo")
                return analysis_prompt
        
            # Unisci le sezioni filtrate
            filtered_prompt = ''.join(filtered_sections)
        
            self.add_log(f"‚úÖ Prompt filtrato: {len(filtered_prompt)} caratteri, {len(filtered_sections)} sezioni")
            return filtered_prompt
        
        except Exception as e:
            self.add_log(f"‚ö†Ô∏è Errore nel filtraggio del prompt: {str(e)}")
            # In caso di errore, restituisci il prompt originale
            return analysis_prompt
    
    def take_debug_screenshot(self, prefix):
        """Scatta uno screenshot per debugging"""
        try:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = f"debug_{prefix}_{timestamp}.png"
            self.driver.save_screenshot(filename)
            self.add_log(f"üì∏ Screenshot di debug salvato: {filename}")
            return filename
        except Exception as e:
            self.add_log(f"‚ö†Ô∏è Impossibile salvare screenshot: {str(e)}")
            return None

    def get_last_response(self):
        """Recupera l'ultima risposta dalla chat con controlli migliorati per terminazione."""
        try:
            # Prova diversi selettori per trovare i messaggi
            selectors = [
                "div.chat-wrapper div.desc > div > div > div",
                "div.chat-wrapper div.desc",
                "div.message-wrap div.message div.text-wrap",
                "div.message div.text-wrap",
                "div.desc",
                # Aggiungi selettori pi√π specifici per Genspark
                ".message-content",
                ".message-bubble .content",
                ".chat-message-item .content"
            ]
        
            # Aggiungi un ritardo prima di cercare le risposte
            time.sleep(2)
        
            for selector in selectors:
                try:
                    messages = self.driver.find_elements(By.CSS_SELECTOR, selector)
                    if messages:
                        # Prendi gli ultimi 2 messaggi (potrebbe esserci un messaggio di sistema)
                        for idx in range(min(2, len(messages))):
                            last_message = messages[-(idx+1)]
                            text = last_message.text.strip()
                        
                            # Verifica che non sia un messaggio di errore
                            if text and not ("errore" in text.lower() or 
                                             "abortita" in text.lower() or
                                             "rigenera" in text.lower()):
                                # Log di debug
                                print(f"DEBUG - Risposta trovata con selettore {selector}, lunghezza: {len(text)}")
                            
                                # NUOVO: Verifica terminatori espliciti
                                terminators = ["FINE", "FINE_RISPOSTA", "COMPLETATO", "ANALISI COMPLETATA"]
                                for terminator in terminators:
                                    if terminator in text:
                                        # Tronca il testo al terminatore
                                        text = text[:text.find(terminator)].strip()
                                        # Log per indicare che √® stata trovata una terminazione esplicita
                                        print(f"DEBUG - Terminatore '{terminator}' trovato nella risposta")
                                        return text
                            
                                return text
                except Exception as e:
                    print(f"DEBUG - Errore con selettore {selector}: {str(e)}")
                    continue
        
            # Se arriviamo qui, proviamo un approccio JavaScript diretto
            try:
                js_result = self.driver.execute_script("""
                    // Recupera tutte le risposte visibili
                    var messages = document.querySelectorAll('.message-content, .chat-message-item, .chat-wrapper .desc');
                    if (messages && messages.length > 0) {
                        return messages[messages.length - 1].textContent;
                    }
                    return null;
                """)
            
                if js_result:
                    print(f"DEBUG - Risposta trovata tramite JavaScript: {len(js_result)} caratteri")
                    return js_result
            except Exception as e:
                print(f"DEBUG - Errore nel recupero JavaScript: {str(e)}")
        
            print("DEBUG - Nessuna risposta trovata con alcun metodo")
            return None
    
        except Exception as e:
            self.add_log(f"Errore nel recupero della risposta: {str(e)}")
            return None

    def handle_context_limit(self):
        """
        Gestisce il limite di contesto in Genspark: rileva proattivamente quando il contesto
        diventa troppo grande o quando appare un messaggio di errore, e fa un reset completo.

        Returns:
            bool: True se il contesto √® stato ripristinato, False altrimenti
        """

        # Ottieni il driver dall'oggetto self
        driver = self.driver

        # 1) Lista estesa dei messaggi di errore da rilevare
        error_indicators = [
            "Context Length Exceeded",
            "Please open a new session",
            "Create a new session",
            "Limite di contesto",
            "exceeded maximum",
            "longer than",
            "too long",
            "richiesta abortita",
            "request aborted",
            "token limit",
            "try again",
            "capacity"
        ]

        # 2) Ricerca pi√π ampia degli indicatori di errore in tutta la pagina
        for indicator in error_indicators:
            try:
                # Usa XPath per cercare il testo ovunque nella pagina
                elements = driver.find_elements(By.XPATH, f"//*[contains(text(), '{indicator}')]")
                if elements:
                    print(f"‚ö†Ô∏è Rilevato possibile limite di contesto: '{indicator}'. Eseguo reset del contesto...")
                    return self.reset_context_manual(self.driver)  
            except Exception as e:
                print(f"Errore durante la ricerca dell'indicatore '{indicator}': {str(e)}")

        # 3) Controllo proattivo della lunghezza della chat (numero di messaggi)
        try:
            messages = driver.find_elements(By.CSS_SELECTOR, ".message-content, .chat-message-item, .message")
            message_count = len(messages)
    
            # Se ci sono troppi messaggi (pi√π di 10-15), meglio fare un reset preventivo
            if message_count > 12:
                print(f"‚ö†Ô∏è Rilevati {message_count} messaggi nella chat (limite preventivo: 12). Eseguo reset del contesto...")
                return self.reset_context_manual(self.driver)  # <-- QUESTA √à UN'ALTRA RIGA DA MODIFICARE
        except Exception as e:
            print(f"Errore durante il conteggio dei messaggi: {str(e)}")

        # 4) Verifica la lunghezza del testo visibile nei messaggi
        try:
            total_text_length = 0
            for message in messages:
                total_text_length += len(message.text)
    
            # Se la lunghezza totale supera una soglia (es. 10K caratteri), reset preventivo
            if total_text_length > 10000:
                print(f"‚ö†Ô∏è Rilevati {total_text_length} caratteri nella chat (limite preventivo: 10000). Eseguo reset del contesto...")
                return self.reset_context_manual(self.driver)  # <-- QUESTA √à UN'ALTRA RIGA DA MODIFICARE
        except Exception as e:
            print(f"Errore durante il calcolo della lunghezza del testo: {str(e)}")

        # Se nessuna condizione √® stata soddisfatta, non √® necessario fare il reset
        return False


    def reset_context_manual(self, driver):
        """
        Reset completo del contesto: chiude la chat corrente, apre una nuova sessione,
        e ricarica il contesto se necessario.
        """
        try:
            print("‚ôªÔ∏è Inizio reset completo del contesto...")
    
            # 1. Backup rapido del contesto visibile (opzionale)
            try:
                messages = driver.find_elements(By.CSS_SELECTOR, ".message-content")
                if messages:
                    # Crea una directory di backup se non esiste
                    backup_dir = Path("backup_context")
                    backup_dir.mkdir(exist_ok=True)
            
                    # Salva il testo visibile in un file di backup
                    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                    backup_path = backup_dir / f"context_backup_{timestamp}.txt"
            
                    with open(backup_path, "w", encoding="utf-8") as f:
                        for msg in messages:
                            f.write(f"--- MESSAGGIO ---\n{msg.text}\n\n")
            
                    print(f"‚úÖ Backup del contesto salvato in {backup_path}")
            except Exception as e:
                print(f"‚ö†Ô∏è Errore nel backup del contesto: {str(e)}")
    
            # 2. Prova diversi metodi per pulire/resettare la chat
            # Metodo 1: Cerca e clicca sul pulsante "New Chat"
            try:
                new_chat_button = driver.find_element(By.XPATH, "//button[contains(text(), 'New Chat') or contains(@aria-label, 'New chat')]")
                new_chat_button.click()
                print("‚úÖ Nuova chat creata tramite pulsante 'New Chat'")
                time.sleep(10)  # Attesa pi√π lunga dopo la creazione della nuova chat
                return True
            except Exception:
                print("‚ö†Ô∏è Pulsante 'New Chat' non trovato, provo metodo alternativo...")
    
            # Metodo 2: Vai alla homepage e cerca il pulsante "New Chat"
            try:
                driver.get("https://genspark.ai")
                print("‚úÖ Navigazione alla homepage completata")
                time.sleep(15)  # Attesa pi√π lunga dopo la navigazione
        
                # Cerca nuovamente il pulsante "New Chat"
                try:
                    new_chat_buttons = driver.find_elements(By.XPATH, 
                        "//button[contains(text(), 'New Chat') or contains(text(), 'Nuova Chat')]")
            
                    if new_chat_buttons:
                        new_chat_buttons[0].click()
                        print("‚úÖ Nuova chat creata tramite pulsante dalla homepage")
                        time.sleep(10)
                        return True
                except Exception:
                    print("‚ö†Ô∏è Pulsante 'New Chat' non trovato sulla homepage")
            except Exception as e:
                print(f"‚ö†Ô∏è Errore nella navigazione alla homepage: {str(e)}")
    
            # Metodo 3: Ricarica completamente la pagina e sfrutta JavaScript (metodo pi√π aggressivo)
            try:
                driver.get("https://genspark.ai")
                time.sleep(15)
        
                # Usa JavaScript per cercare e cliccare qualsiasi bottone di nuova chat
                js_script = """
                var buttons = document.querySelectorAll('button');
                for(var i = 0; i < buttons.length; i++) {
                    if(buttons[i].innerText.includes('New Chat') || 
                       buttons[i].innerText.includes('Nuova Chat') ||
                       buttons[i].getAttribute('aria-label') && buttons[i].getAttribute('aria-label').includes('chat')) {
                        buttons[i].click();
                        return true;
                    }
                }
                return false;
                """
        
                result = driver.execute_script(js_script)
                if result:
                    print("‚úÖ Nuova chat creata tramite JavaScript")
                    time.sleep(10)
                    return True
                else:
                    print("‚ö†Ô∏è Nessun pulsante di nuova chat trovato tramite JavaScript")
            except Exception as e:
                print(f"‚ö†Ô∏è Errore nel reset tramite JavaScript: {str(e)}")
    
            # Metodo 4: Ultima risorsa - ricarica semplice
            try:
                driver.get("https://genspark.ai")
                print("‚ö†Ô∏è Reset di emergenza tramite ricarica pagina")
                time.sleep(15)
                return True
            except Exception as e:
                print(f"‚ùå Tutti i metodi di reset falliti: {str(e)}")
                return False
        
        except Exception as e:
            print(f"‚ùå Errore critico nel reset del contesto: {str(e)}")
            return False

    def update_analysis_status(self, status_text, progress_percentage=None):
        """
        Aggiorna lo stato dell'analisi nell'interfaccia.
    
        Args:
            status_text: Testo dello stato
            progress_percentage: Percentuale di completamento (opzionale)
        """
        if hasattr(self, 'analysis_status'):
            try:
                if progress_percentage is not None:
                    status_html = f"""
                    <div class="status-container">
                        <div class="status-text mb-2"><strong>Stato:</strong> {status_text}</div>
                        <div class="progress-bar-container bg-gray-200 rounded-full h-4 w-full">
                            <div class="progress-bar bg-blue-600 h-4 rounded-full" style="width: {progress_percentage}%;"></div>
                        </div>
                        <div class="text-right text-sm text-gray-500">{progress_percentage}%</div>
                    </div>
                    """
                else:
                    status_html = f"<div class='status-text'><strong>Stato:</strong> {status_text}</div>"
                
                self.analysis_status.update(value=status_html)
                self.add_log(f"üìä Stato analisi aggiornato: {status_text}")
            except Exception as e:
                self.add_log(f"‚ö†Ô∏è Errore nell'aggiornamento dello stato: {str(e)}")

    def show_feedback(self, title, message, type="info"):
        """
        Mostra un messaggio di feedback all'utente.
    
        Args:
            title: Titolo del messaggio
            message: Testo del messaggio
            type: Tipo di messaggio (info, success, warning, error)
        """
        try:
            # Determina il colore in base al tipo
            color_class = {
                "info": "blue",
                "success": "green",
                "warning": "yellow",
                "error": "red"
            }.get(type, "blue")
        
            feedback_html = f"""
            <div class="bg-{color_class}-50 border-l-4 border-{color_class}-500 p-4 mb-4">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-5 w-5 text-{color_class}-400" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
                        </svg>
                    </div>
                    <div class="ml-3">
                        <h3 class="text-{color_class}-800 font-medium">{title}</h3>
                        <div class="mt-2 text-{color_class}-700">
                            <p>{message}</p>
                        </div>
                    </div>
                </div>
            </div>
            """
        
            # Aggiorna l'interfaccia appropriata
            if hasattr(self, 'results_display'):
                current_value = self.results_display.value or ""
                self.results_display.update(value=feedback_html + current_value)
        
            self.add_log(f"üí¨ Feedback mostrato: {title}")
        except Exception as e:
            self.add_log(f"‚ö†Ô∏è Errore nella visualizzazione del feedback: {str(e)}")

    def create_focused_context(self, original_context_file, max_size=8000):
        """
        Crea una versione condensata del contesto focalizzata sulle informazioni essenziali.
    
        Args:
            original_context_file: Percorso del file di contesto originale
            max_size: Dimensione massima in caratteri
        
        Returns:
            str: Percorso del file di contesto condensato o None in caso di errore
        """
        try:
            import re
        
            self.add_log(f"Creazione contesto condensato da {original_context_file}...")
        
            with open(original_context_file, 'r', encoding='utf-8') as f:
                full_content = f.read()
        
            # Estrai le sezioni pi√π importanti
            important_sections = []
            condensed_content = ["CONTESTO CONDENSATO PER CONTINUAZIONE ANALISI:\n\n"]
        
            # 1. Estrai informazioni sul progetto corrente
            project_info = re.search(r'===\s+Analisi CRISP 5\.0[^=]+(.*?)(?=\n===|$)', full_content, re.DOTALL)
            if project_info:
                condensed_content.append(f"[INFORMAZIONI PROGETTO]\n{project_info.group(1).strip()}\n\n")
        
            # 2. Estrai variabili di mercato importanti
            key_vars = ["MARKET_INSIGHTS", "KEYWORD_DATA", "BESTSELLER_OVERVIEW", 
                       "STRUCTURE_PATTERNS", "TITLE_PATTERNS", "REVIEW_INSIGHTS"]
        
            for var in key_vars:
                var_pattern = re.compile(f"{var}[\\s]*:[\\s]*(.*?)(?=\\n[A-Z_]+:|$)", re.DOTALL)
                var_match = var_pattern.search(full_content)
                if var_match:
                    content = var_match.group(1).strip()
                    # Tronca a 500 caratteri se pi√π lungo
                    if len(content) > 500:
                        content = content[:497] + "..."
                    condensed_content.append(f"{var}:\n{content}\n\n")
        
            # 3. Estrai l'ultima parte della conversazione (ultime 2-3 sezioni)
            sections = re.findall(r'===\s+([^=\n]+)\s+-\s+([^=\n]+)\s+===\n([\s\S]*?)(?=\n===|$)', full_content)
        
            # Prendi solo le ultime 3 sezioni
            recent_sections = sections[-3:] if len(sections) > 3 else sections
        
            for section_name, timestamp, content in recent_sections:
                # Tronca il contenuto se troppo lungo
                if len(content) > 1000:
                    content = content[:997] + "..."
                condensed_content.append(f"=== {section_name} - {timestamp} ===\n{content.strip()}\n\n")
        
            # Combina e verifica la dimensione
            final_content = "".join(condensed_content)
        
            # Se ancora troppo grande, tronca ulteriormente
            if len(final_content) > max_size:
                half_size = max_size // 2
                final_content = (
                    final_content[:half_size] + 
                    "\n\n[...CONTENUTO OMESSO PER LIMITI DI DIMENSIONE...]\n\n" + 
                    final_content[-half_size:]
                )
        
            # Salva il contesto condensato
            condensed_file = original_context_file.replace('.txt', '_condensed.txt')
            with open(condensed_file, 'w', encoding='utf-8') as f:
                f.write(final_content)
        
            self.add_log(f"Contesto condensato creato: {len(final_content)} caratteri")
            return condensed_file
    
        except Exception as e:
            self.add_log(f"‚ùå Errore nella creazione del contesto condensato: {str(e)}")
            return None

    def send_essential_context(self, driver, context_file):
        """
        Invia un riepilogo essenziale del contesto come messaggio diretto.
    
        Args:
            driver: WebDriver di Selenium
            context_file: Percorso del file di contesto
        
        Returns:
            bool: True se l'invio √® riuscito, False altrimenti
        """
        try:
            self.add_log("Invio riepilogo essenziale del contesto...")
        
            # Estrai le informazioni chiave dal file di contesto
            with open(context_file, 'r', encoding='utf-8') as f:
                content = f.read()
        
            # Estrai il progetto e la keyword
            project_match = re.search(r'Progetto:\s*([^\n]+)', content)
            keyword_match = re.search(r'Keyword:\s*([^\n]+)', content)
            market_match = re.search(r'Mercato:\s*([^\n]+)', content)
        
            project = project_match.group(1).strip() if project_match else "Progetto sconosciuto"
            keyword = keyword_match.group(1).strip() if keyword_match else "Keyword sconosciuta"
            market = market_match.group(1).strip() if market_match else "Mercato sconosciuto"
        
            # Crea un messaggio di riepilogo conciso
            summary = f"""
            RIPRISTINO ANALISI CRISP:
        
            Stavo analizzando il mercato di "{keyword}" su {market}.
            ID progetto: {project}
        
            Ho dovuto aprire una nuova sessione per limiti di contesto.
            Sto continuando l'analisi dal punto in cui era stata interrotta.
        
            Per favore, continua l'analisi precedente.
            """
        
            # Trova l'input box
            input_box = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper textarea"))
            )
        
            # Pulisci l'input box
            input_box.clear()
            time.sleep(0.5)
        
            # Invia il riepilogo per piccoli blocchi
            for chunk in [summary[i:i+100] for i in range(0, len(summary), 100)]:
                input_box.send_keys(chunk)
                time.sleep(0.1)
        
            time.sleep(1)
        
            # Trova e clicca il pulsante di invio
            send_button = WebDriverWait(driver, 10).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper div.input-icon"))
            )
            send_button.click()
        
            # Attendi l'elaborazione
            time.sleep(10)
        
            self.add_log("Riepilogo essenziale inviato con successo")
            return True
        
        except Exception as e:
            self.add_log(f"‚ùå Errore nell'invio del riepilogo essenziale: {str(e)}")
            return False

    def check_for_generation_error(self, response):
        """Verifica se c'√® un errore di generazione e tenta di rigenerare"""
        error_patterns = [
            "Si √® verificato un errore", 
            "Errore durante la generazione",
            "Errore di generazione",
            "problema nella generazione"
        ]
    
        # Verifica se la risposta contiene uno dei pattern di errore (case insensitive)
        has_error = any(pattern.lower() in response.lower() for pattern in error_patterns)
    
        if has_error or (response and len(response) < 30):  # Risposta troppo corta o con errore
            self.add_log("‚ö†Ô∏è Rilevato messaggio di errore nella generazione")
        
            # Scatta screenshot dell'errore
            screenshot_path = f"error_screenshot_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
            self.driver.save_screenshot(screenshot_path)
            self.add_log(f"üì∏ Screenshot errore salvato: {screenshot_path}")
        
            # MIGLIORAMENTO: Trova tutti i possibili pulsanti di rigenerazione con vari selettori
            regenerate_selectors = [
                "//button[contains(text(), 'Rigenera')]",
                "//button[contains(text(), 'Regenerate')]",
                "//button[contains(@class, 'regenerate')]",
                "//div[contains(@class, 'regenerate')]",
                "//button[contains(@aria-label, 'Rigenera')]"
            ]
        
            for selector in regenerate_selectors:
                try:
                    buttons = self.driver.find_elements(By.XPATH, selector)
                    if buttons:
                        self.add_log(f"üîç Trovato pulsante di rigenerazione con selettore: {selector}")
                    
                        # NUOVO: Aggiunta di debug visivo
                        self.driver.execute_script("""
                            arguments[0].style.border = '3px solid red';
                            arguments[0].style.backgroundColor = 'yellow';
                        """, buttons[0])
                        time.sleep(1)  # Pausa per vedere l'evidenziazione
                    
                        # Clicca sia con JavaScript che normalmente per maggiore affidabilit√†
                        try:
                            self.driver.execute_script("arguments[0].click();", buttons[0])
                            self.add_log("üîÑ Clic su 'Rigenera' tramite JavaScript")
                        except:
                            buttons[0].click()
                            self.add_log("üîÑ Clic su 'Rigenera' tramite metodo standard")
                    
                        time.sleep(15)  # Attesa per rigenerazione
                        return True
                except Exception as e:
                    self.add_log(f"‚ö†Ô∏è Errore con selettore {selector}: {str(e)}")
        
            self.add_log("‚ùå Nessun pulsante di rigenerazione trovato!")
            return False
    
        return False

    def handle_consecutive_errors(self, prompt_text, max_retries=3):
        """Gestisce errori consecutivi tentando approcci alternativi"""
        self.add_log(f"üîÑ Tentativo di ripristino dopo errori consecutivi ({max_retries} tentativi)")
    
        for retry in range(max_retries):
            self.add_log(f"Tentativo di recupero {retry+1}/{max_retries}")
        
            # Prova reset del contesto
            if self.handle_context_limit():
                self.add_log("‚úÖ Contesto resettato con successo")
            
                # Riprova con lo stesso prompt
                input_box = WebDriverWait(self.driver, 10).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper textarea"))
                )
                input_box.clear()
                time.sleep(1)
            
                # Inserisci il prompt originale (possibilmente modificato)
                modified_prompt = f"{prompt_text}\n\n(Tentativo di recupero {retry+1})"
                self.add_log(f"üîÑ Reinvio prompt modificato: {modified_prompt[:50]}...")
            
                # Invia e attendi
                input_box.send_keys(modified_prompt)
                time.sleep(1)
            
                # Trova e clicca il pulsante di invio
                send_button = WebDriverWait(self.driver, 10).until(
                    EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper div.input-icon"))
                )
                send_button.click()
            
                # Attendi
                time.sleep(20)
            
                # Verifica la risposta
                response = self.get_last_response()
                if response and len(response) > 100 and "errore" not in response.lower():
                    self.add_log("‚úÖ Recupero riuscito!")
                    return response
        
            # Aumenta il tempo di attesa tra i tentativi
            wait_time = 10 + (retry * 5)
            self.add_log(f"‚è±Ô∏è Attesa {wait_time} secondi prima del prossimo tentativo...")
            time.sleep(wait_time)
    
        self.add_log("‚ùå Tutti i tentativi di recupero falliti")
        return "[ERRORE: Impossibile ottenere una risposta valida dopo multipli tentativi]"

    def continue_analysis(self):
        """Continua l'analisi dopo una pausa manuale"""
        try:
            # Controlla se stai usando CRISP
            if hasattr(self, 'use_crisp') and self.use_crisp and hasattr(self, 'current_analysis') and self.current_analysis.get('crisp_project_id'):
                return self._continue_analysis_crisp()
            else:
                return self._continue_analysis_legacy()
        except Exception as e:
            print(f"DEBUG ERROR: {str(e)}")
            return self.add_log(f"Errore durante il completamento dell'analisi: {str(e)}")
            
    def _continue_analysis_crisp(self):
        """Continua l'analisi CRISP dopo una pausa manuale"""
        try:
            self.add_log("Continuazione analisi PubliScript...")
            # Ottieni la risposta attuale dalla chat
            response = self.get_last_response()
            
            if not response:
                return self.add_log("Non √® stato possibile recuperare la risposta dalla chat")
            
            # Recupera l'ID del progetto CRISP
            project_id = self.current_analysis.get('crisp_project_id')
            if not project_id:
                return self.add_log("Errore: Nessun progetto CRISP trovato")
            
            # Determina quale fase CRISP √® stata interrotta
            execution_history = self.current_analysis.get('execution_history', [])
            if not execution_history:
                return self.add_log("Errore: Nessuna storia di esecuzione trovata")
            
            last_step = execution_history[-1]['step_id']
            self.add_log(f"Ripresa dall'ultimo step completato: {last_step}")
            
            # Salva la risposta nel database
            # Aggiorna i dati del progetto con la nuova risposta
            self.chat_manager.save_response(
                response,
                f"Continuazione CRISP - {last_step}",
                {"project_id": project_id, "manual_continuation": True}
            )
            
            # Continua l'esecuzione del flusso CRISP
            # Definisci una funzione executor per continuare
            def continue_executor(prompt_text):
                self.add_log(f"Continuazione prompt CRISP ({len(prompt_text)} caratteri)...")
                lines = [line.strip() for line in prompt_text.split('\n') if line.strip()]
                cumulative_response = []
                
                for i, line in enumerate(lines):
                    self.add_log(f"Linea {i+1}/{len(lines)}: {line[:50]}...")
                    response = self.send_to_genspark(line)
                    cumulative_response.append(response)
                    time.sleep(2)
                
                combined_response = "\n\n".join(cumulative_response)
                self.chat_manager.save_response(
                    combined_response,
                    "Continuazione CRISP",
                    {"project_id": project_id}
                )
                return combined_response
            
            # Aggiorna l'interfaccia per indicare che la continuazione √® in corso
            self.add_log("üîÑ Ripresa dell'analisi CRISP...")
            
            # In un'implementazione reale, qui chiameresti il metodo del framework CRISP 
            # per continuare dal punto di interruzione. Per√≤, poich√© il framework non ha 
            # un metodo specifico per questo, dovresti implementare la logica tu stesso.
            self.add_log("‚úÖ Analisi CRISP continuata con successo")
            return self.chat_manager.get_log_history_string()
            
        except Exception as e:
            error_msg = f"Errore durante la continuazione dell'analisi CRISP: {str(e)}"
            self.add_log(error_msg)
            logging.error(error_msg)
            return self.chat_manager.get_log_history_string()
    
    
    def complete_analysis(self):
        """
        Completa l'analisi e prepara i dettagli del libro.
        Estrae le informazioni critiche dal file di contesto o dal database CRISP
        e le prepara per la generazione del libro.
        """
        import re  # Importazione esplicita di re per evitare l'errore "variable referenced before assignment"
        import os
        import traceback
        import gradio as gr  # Aggiungi questa riga per importare gr all'interno del metodo
        from datetime import datetime
         
        # ==================== FASE 1: DIAGNOSTICA INIZIALE ====================
        # Verifica se il file di contesto esiste e stampa informazioni diagnostiche
        print(f"DEBUG-INIT: Avvio complete_analysis() con dettagli estesi")
        print(f"DEBUG-INIT: Tentativo di lettura del file context.txt - Esiste: {os.path.exists('context.txt')}")
        print(f"DEBUG-INIT: Directory corrente: {os.getcwd()}")
        print(f"DEBUG-INIT: Memoria disponibile per gli oggetti Python")

        # Verifica se ci sono dati nel current_analysis
        if hasattr(self, 'current_analysis'):
            print(f"DEBUG-INIT: current_analysis esiste: {type(self.current_analysis)}")
            if self.current_analysis:
                print(f"DEBUG-INIT: current_analysis contiene {len(self.current_analysis)} elementi")
                # Mostra le chiavi principali
                for key in list(self.current_analysis.keys())[:5]:  # Limita a 5 chiavi per leggibilit√†
                    print(f"DEBUG-INIT: - Chiave: {key}, Tipo: {type(self.current_analysis[key])}")
            else:
                print("DEBUG-INIT: current_analysis √® un dizionario vuoto o None")
        else:
            print("DEBUG-INIT: current_analysis non esiste come attributo")

        # Backup del file di contesto prima di iniziare l'elaborazione
        if os.path.exists("context.txt"):
            try:
                file_size = os.path.getsize("context.txt")
                print(f"DEBUG-CONTEXT: File context.txt trovato - Dimensione: {file_size} bytes")
        
                # Leggi l'intestazione del file per debug
                try:
                    with open("context.txt", "r", encoding="utf-8") as f:
                        # Leggi le prime 10 righe o meno se il file √® pi√π corto
                        first_lines = []
                        for _ in range(10):
                            try:
                                line = next(f)
                                first_lines.append(line)
                            except StopIteration:
                                break
                
                        print(f"DEBUG-CONTEXT: Prime {len(first_lines)} righe del file:")
                        for i, line in enumerate(first_lines):
                            print(f"DEBUG-CONTEXT: Riga {i+1}: {line.strip()}")
                except Exception as e:
                    print(f"DEBUG-CONTEXT: Errore nella lettura dell'intestazione del file: {str(e)}")
                    print(f"DEBUG-CONTEXT: Traceback errore intestazione:\n{traceback.format_exc()}")
        
                # Crea backup con timestamp
                import shutil
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                backup_file = f"context_backup_{timestamp}.txt"
                shutil.copy2("context.txt", backup_file)
                backup_size = os.path.getsize(backup_file)
                print(f"DEBUG-CONTEXT: Backup creato: {backup_file} ({backup_size} bytes)")
        
                # Leggi e stampa un'anteprima del contenuto
                try:
                    with open("context.txt", "r", encoding="utf-8") as f:
                        # Leggi i primi 300 caratteri per anteprima
                        context_preview = f.read(300)
                        print(f"DEBUG-CONTEXT: Anteprima del contenuto (primi 300 caratteri):")
                        # Sostituisci i caratteri di nuova riga con \n visibili
                        context_preview_formatted = context_preview.replace('\n', '\\n')
                        print(f"DEBUG-CONTEXT: {context_preview_formatted}")
                except Exception as e:
                    print(f"DEBUG-CONTEXT: Errore nella lettura dell'anteprima: {str(e)}")
    
            except Exception as backup_error:
                print(f"DEBUG-CONTEXT: Errore nel backup del file di contesto: {str(backup_error)}")
                print(f"DEBUG-CONTEXT: Traceback errore backup:\n{traceback.format_exc()}")
        else:
            print("DEBUG-CONTEXT: ATTENZIONE - File context.txt non trovato!")
            # Elenca tutti i file nella directory corrente per debug
            print("DEBUG-CONTEXT: Elenco dei file nella directory corrente:")
            try:
                files = os.listdir()
                for file in files:
                    if os.path.isfile(file):
                        print(f"DEBUG-CONTEXT: - {file} ({os.path.getsize(file)} bytes)")
            except Exception as e:
                print(f"DEBUG-CONTEXT: Errore nell'elenco dei file: {str(e)}")


        # ================ FASE 2: INIZIO DELL'ELABORAZIONE PRINCIPALE ================
        try:
            # Aggiungi al log
            self.add_log("‚ñ∂Ô∏è Avvio funzione complete_analysis")
    
            # Inizializza current_analysis se non esiste
            if not hasattr(self, 'current_analysis') or self.current_analysis is None:
                self.current_analysis = {}
                self.add_log("‚ÑπÔ∏è Inizializzato current_analysis (non esisteva)")
                print("DEBUG-INIT: current_analysis inizializzato (era None)")
            else:
                print(f"DEBUG-INIT: current_analysis gi√† esistente con {len(self.current_analysis)} chiavi")
                # Debug delle chiavi esistenti
                for key in self.current_analysis:
                    value_preview = str(self.current_analysis[key])
                    if len(value_preview) > 100:
                        value_preview = value_preview[:100] + "..."
                    print(f"DEBUG-INIT: - chiave: {key}, valore: {value_preview}")

            # ================ FASE 3: INIZIALIZZAZIONE VALORI DI RITORNO ================
            # Prepara i valori che verranno restituiti alla fine
            analysis_status_text = "**Stato analisi**: Completata"
            tabs_value = gr.Tabs(selected=2)  # Seleziona il tab "Generazione Libro"
            book_title_value = ""             # Titolo estratto dall'analisi
            book_index_value = ""             # Indice estratto dall'analisi
            voice_style_value = ""            # Stile di voce estratto dall'analisi
            book_type_value = ""              # Tipo di libro estratto dall'analisi
    
            print("DEBUG-VALUES: Valori di ritorno inizializzati con stringhe vuote")

            # ================ FASE 4: DETERMINA LA MODALIT√Ä (CRISP o LEGACY) ================
            # Verifica se si sta utilizzando il framework CRISP
            use_crisp = hasattr(self, 'use_crisp') and self.use_crisp
            self.add_log(f"‚ÑπÔ∏è Modalit√† CRISP: {use_crisp}")
            print(f"DEBUG-MODE: Utilizzo framework CRISP: {use_crisp}")
    
            # ================ FASE 5A: ELABORAZIONE MODALIT√Ä CRISP ================
            if use_crisp and hasattr(self, 'current_analysis') and self.current_analysis.get('crisp_project_id'):
                print("DEBUG-CRISP: Avvio elaborazione in modalit√† CRISP")
                self.add_log("üîç Tentativo di estrazione dati da progetto CRISP")
        
                # Recupera l'ID del progetto CRISP
                project_id = self.current_analysis.get('crisp_project_id')
                if not project_id:
                    self.add_log("‚ö†Ô∏è ID Progetto CRISP non trovato nella current_analysis")
                    print("DEBUG-CRISP: ID Progetto CRISP non trovato - impossibile recuperare dati")
                else:
                    self.add_log(f"‚úÖ ID Progetto CRISP trovato: {project_id}")
                    print(f"DEBUG-CRISP: ID Progetto CRISP trovato: {project_id}")
            
                    # Recupera i dati completi del progetto dal framework CRISP
                    project_data = None
                    try:
                        # Verifica se √® possibile accedere ai dati del progetto
                        if hasattr(self, 'crisp') and hasattr(self.crisp, 'get_project_data'):
                            print(f"DEBUG-CRISP: Tentativo recupero dati con crisp.get_project_data({project_id})")
                    
                            # Chiamata effettiva per recuperare i dati
                            project_data = self.crisp.get_project_data(project_id)
                    
                            if project_data:
                                print(f"DEBUG-CRISP: Dati progetto recuperati: {len(project_data)} variabili")
                        
                                # Stampa le prime 10 variabili per debug
                                counter = 0
                                for key, value in project_data.items():
                                    if counter < 10:
                                        value_str = str(value)
                                        if len(value_str) > 100:
                                            value_str = value_str[:100] + "..."
                                        print(f"DEBUG-CRISP: Variabile {counter+1}: {key} = {value_str}")
                                        counter += 1
                                    else:
                                        break
                        
                                self.add_log(f"‚úÖ Dati progetto recuperati: {len(project_data)} variabili")
                            else:
                                print("DEBUG-CRISP: ERRORE - get_project_data ha restituito None")
                                self.add_log("‚ö†Ô∏è get_project_data ha restituito None")
                        else:
                            print("DEBUG-CRISP: ERRORE - crisp o get_project_data non disponibili")
                    
                            # Diagnostica dettagliata
                            if hasattr(self, 'crisp'):
                                print(f"DEBUG-CRISP: self.crisp esiste: {type(self.crisp)}")
                                print(f"DEBUG-CRISP: hasattr(self.crisp, 'get_project_data'): {hasattr(self.crisp, 'get_project_data')}")
                        
                                # Elenca tutti i metodi disponibili per debug
                                methods = [method for method in dir(self.crisp) if not method.startswith('_')]
                                print(f"DEBUG-CRISP: Metodi disponibili in self.crisp: {methods}")
                            else:
                                print("DEBUG-CRISP: self.crisp non esiste come attributo")
            
                    except Exception as e:
                        self.add_log(f"‚ö†Ô∏è Errore nel recupero dati progetto CRISP: {str(e)}")
                        print(f"DEBUG-CRISP: Eccezione in get_project_data: {str(e)}")
                        print(f"DEBUG-CRISP: Traceback dettagliato:\n{traceback.format_exc()}")
            
                    # ================ FASE 5A-1: ESTRAZIONE DATI DAL PROGETTO CRISP ================
                    # Se abbiamo recuperato i dati del progetto, estrai le informazioni necessarie
                    if project_data:
                        # Salva i dati del progetto per uso futuro
                        self.current_analysis['project_data'] = project_data
                        print("DEBUG-CRISP: project_data salvato in current_analysis per uso futuro")
                
                        # ---------- Estrazione Titolo ----------
                        if 'TITOLO_LIBRO' in project_data:
                            book_title_value = project_data.get('TITOLO_LIBRO', '')
                            self.add_log(f"‚úÖ Titolo estratto: {book_title_value}")
                            print(f"DEBUG-CRISP: Titolo estratto: '{book_title_value}'")
                        else:
                            print("DEBUG-CRISP: TITOLO_LIBRO non trovato nei dati del progetto")
                            # Cerca alternative per il titolo
                            for alt_key in ['TITLE', 'BOOK_TITLE', 'TITOLO']:
                                if alt_key in project_data:
                                    book_title_value = project_data.get(alt_key, '')
                                    print(f"DEBUG-CRISP: Titolo trovato in campo alternativo {alt_key}: {book_title_value}")
                                    break
                
                        # ---------- Estrazione Stile di Voce ----------
                        if 'VOICE_STYLE' in project_data:
                            voice_style_value = project_data.get('VOICE_STYLE', '')
                            self.add_log(f"‚úÖ Stile voce estratto: {voice_style_value}")
                            print(f"DEBUG-CRISP: Stile voce estratto: '{voice_style_value}'")
                        else:
                            print("DEBUG-CRISP: VOICE_STYLE non trovato nei dati del progetto")
                            # Cerca alternative per lo stile di voce
                            for alt_key in ['TONE', 'STYLE', 'WRITING_STYLE']:
                                if alt_key in project_data:
                                    voice_style_value = project_data.get(alt_key, '')
                                    print(f"DEBUG-CRISP: Stile voce trovato in campo alternativo {alt_key}: {voice_style_value}")
                                    break
                
                        # ---------- Estrazione Tipo di Libro ----------
                        if 'LIBRO_TIPO' in project_data:
                            book_type_value = project_data.get('LIBRO_TIPO', '')
                            self.add_log(f"‚úÖ Tipo di libro estratto: {book_type_value}")
                            print(f"DEBUG-CRISP: Tipo di libro estratto: '{book_type_value}'")
                        else:
                            print("DEBUG-CRISP: LIBRO_TIPO non trovato nei dati del progetto")
                            # Cerca alternative per il tipo di libro
                            for alt_key in ['BOOK_TYPE', 'TIPO', 'GENRE']:
                                if alt_key in project_data:
                                    book_type_value = project_data.get(alt_key, '')
                                    print(f"DEBUG-CRISP: Tipo libro trovato in campo alternativo {alt_key}: {book_type_value}")
                                    break
                
                        # ---------- Costruzione Indice del Libro ----------
                        print("DEBUG-CRISP: Tentativo costruzione indice del libro")
                
                        # Cerca CONTENT_PILLARS per la costruzione dell'indice
                        if 'CONTENT_PILLARS' in project_data:
                            self.add_log("üîç Tentativo di costruzione indice da CONTENT_PILLARS")
                            print("DEBUG-CRISP: Tentativo di costruzione indice da CONTENT_PILLARS")
                    
                            pillars_text = project_data.get('CONTENT_PILLARS', '')
                            print(f"DEBUG-CRISP: CONTENT_PILLARS trovato, lunghezza: {len(pillars_text)}")
                            print(f"DEBUG-CRISP: Anteprima CONTENT_PILLARS: {pillars_text[:200]}...")
                    
                            # Estrai i pilastri di contenuto con diversi pattern di espressioni regolari
                            pillars = []
                            if isinstance(pillars_text, str):
                                # Prova diversi pattern per estrarre pilastri
                                print("DEBUG-CRISP: Tentativo di estrazione pilastri con pattern regex")
                        
                                pattern_results = {}
                        
                                for pattern in [
                                    r'(\d+\.\s*[^\n]+)',             # Pattern per "1. Titolo"
                                    r'(\d+\)\s*[^\n]+)',             # Pattern per "1) Titolo"
                                    r'(CAPITOLO \d+[^:\n]*:[^\n]+)', # Pattern per "CAPITOLO 1: Titolo"
                                    r'(Capitolo \d+[^:\n]*:[^\n]+)'  # Pattern per "Capitolo 1: Titolo"
                                ]:
                                    # Prova ogni pattern e registra i risultati
                                    pillar_matches = re.findall(pattern, pillars_text)
                                    pattern_results[pattern] = pillar_matches
                            
                                    if pillar_matches:
                                        print(f"DEBUG-CRISP: Pattern '{pattern}' ha trovato {len(pillar_matches)} corrispondenze")
                                        # Mostra le prime corrispondenze
                                        for i, match in enumerate(pillar_matches[:3]):
                                            print(f"DEBUG-CRISP: --- Match {i+1}: {match}")
                                
                                        if len(pillar_matches) >= 3:  # Minimo 3 capitoli per un buon indice
                                            pillars = [p.strip() for p in pillar_matches]
                                            break
                                    else:
                                        print(f"DEBUG-CRISP: Pattern '{pattern}' non ha trovato corrispondenze")
                        
                                # Se nessun pattern ha funzionato, prova con approcci alternativi
                                if not pillars:
                                    print("DEBUG-CRISP: Nessun pattern regex ha trovato abbastanza pilastri, provo approccio alternativo")
                            
                                    # Approccio alternativo: dividi per righe e cerca linee che sembrano titoli di capitolo
                                    lines = pillars_text.split('\n')
                                    print(f"DEBUG-CRISP: Text diviso in {len(lines)} righe per analisi")
                            
                                    for line in lines:
                                        line = line.strip()
                                        # Verifica se la riga sembra un titolo di capitolo
                                        if line and (
                                            line.lower().startswith('capitolo') or 
                                            line.lower().startswith('chapter') or
                                            re.match(r'^\d+[\.\)]', line)
                                        ):
                                            pillars.append(line)
                                            print(f"DEBUG-CRISP: Trovato potenziale pilastro: {line}")
                            
                                    if pillars:
                                        print(f"DEBUG-CRISP: Approccio alternativo ha trovato {len(pillars)} potenziali pilastri")
                                    else:
                                        print("DEBUG-CRISP: Anche l'approccio alternativo non ha trovato pilastri")
                                
                                        # Ultimo tentativo: cerca qualsiasi riga che sembra un titolo
                                        print("DEBUG-CRISP: Tentativo di ultima risorsa: qualsiasi riga che sembra un titolo")
                                        for line in lines:
                                            line = line.strip()
                                            # Riga abbastanza lunga ma non troppo e con maiuscole all'inizio
                                            if 10 <= len(line) <= 100 and line[0].isupper() and ":" not in line and line.endswith((".","?")):
                                                pillars.append(line)
                                                print(f"DEBUG-CRISP: Titolo potenziale trovato: {line}")
                                                if len(pillars) >= 5:  # Limita a 5 pilastri per questo approccio
                                                    break
                            else:
                                print(f"DEBUG-CRISP: CONTENT_PILLARS non √® una stringa ma un {type(pillars_text)}")
                        
                                # Se CONTENT_PILLARS √® una lista (possibile con alcune implementazioni)
                                if isinstance(pillars_text, list):
                                    print(f"DEBUG-CRISP: CONTENT_PILLARS √® una lista con {len(pillars_text)} elementi")
                                    pillars = pillars_text
                    
                            # Costruisci l'indice a partire dai pilastri trovati
                            if pillars:
                                print(f"DEBUG-CRISP: Costruzione indice con {len(pillars)} pilastri trovati")
                        
                                # Pulisci e formatta l'indice
                                index_text = "INTRODUZIONE\n\n"
                        
                                for i, pillar in enumerate(pillars, 1):
                                    # Rimuovi numeri e simboli di punteggiatura iniziali
                                    try:
                                        clean_pillar = re.sub(r'^\d+[\.\)\s]+|^CAPITOLO\s+\d+\s*[:\.\-\s]*|^Capitolo\s+\d+\s*[:\.\-\s]*', '', pillar).strip()
                                        print(f"DEBUG-CRISP: Pillar {i} originale: '{pillar}'")
                                        print(f"DEBUG-CRISP: Pillar {i} pulito: '{clean_pillar}'")
                                
                                        if clean_pillar:  # Aggiungi solo se c'√® testo dopo la pulizia
                                            index_text += f"CAPITOLO {i}: {clean_pillar}\n\n"
                                        else:
                                            print(f"DEBUG-CRISP: Pillar {i} ha prodotto un testo vuoto dopo la pulizia")
                                            # Usa il testo originale come fallback se la pulizia ha rimosso tutto
                                            index_text += f"CAPITOLO {i}: {pillar}\n\n"
                                    except Exception as e:
                                        print(f"DEBUG-CRISP: Errore nella pulizia del pillar {i}: {str(e)}")
                                        # Usa il testo originale in caso di errore
                                        index_text += f"CAPITOLO {i}: {pillar}\n\n"
                        
                                index_text += "CONCLUSIONE"
                                book_index_value = index_text
                                self.add_log(f"‚úÖ Indice costruito con {len(pillars)} capitoli")
                                print(f"DEBUG-CRISP: Indice costruito con successo:\n{book_index_value}")
                            else:
                                # Indice di fallback se non sono stati trovati pilastri
                                print("DEBUG-CRISP: Nessun pilastro trovato, uso indice di fallback")
                                book_index_value = """INTRODUZIONE

    CAPITOLO 1: Fondamenti

    CAPITOLO 2: Metodologia

    CAPITOLO 3: Applicazione

    CAPITOLO 4: Casi Studio

    CAPITOLO 5: Risultati

    CONCLUSIONE"""
                                self.add_log("‚ö†Ô∏è Usato indice di fallback (nessun pilastro trovato)")
                                print("DEBUG-CRISP: Usato indice di fallback")
                        else:
                            print("DEBUG-CRISP: CONTENT_PILLARS non trovato nei dati del progetto")
                    
                            # Cerca campi alternativi che potrebbero contenere informazioni per l'indice
                            alternative_found = False
                            for key in ['BOOK_STRUCTURE', 'INDICE_LIBRO', 'BOOK_JOURNEY', 'CHAPTER_STRUCTURE']:
                                if key in project_data:
                                    print(f"DEBUG-CRISP: Trovato {key} come alternativa a CONTENT_PILLARS")
                                    self.add_log(f"üîç Tentativo di costruzione indice da {key}")
                            
                                    # Implementazione simile a quella per CONTENT_PILLARS
                                    alternative_text = project_data.get(key, '')
                                    # (Ripeti logica simile a quella usata per CONTENT_PILLARS)
                                    # Per brevit√†, questo codice √® omesso ma sarebbe una duplicazione
                                    # dell'approccio sopra adattato per il campo alternativo
                            
                                    alternative_found = True
                                    break
                    
                            if not alternative_found:
                                print("DEBUG-CRISP: Nessuna alternativa a CONTENT_PILLARS trovata, uso indice di fallback")
                    else:
                        print("DEBUG-CRISP: project_data √® None o vuoto, impossibile estrarre dati")
    
            # ================ FASE 5B: ELABORAZIONE MODALIT√Ä LEGACY ================
            else:
                # Approccio legacy - senza framework CRISP
                self.add_log("üîç Utilizzo approccio legacy (non CRISP)")
                print("DEBUG-LEGACY: Avvio elaborazione in modalit√† legacy (non CRISP)")

                try:
                    # Cerca dati nel file di contesto
                    context_file = "context.txt"
                    if os.path.exists(context_file):
                        # Informazioni sul file
                        file_size = os.path.getsize(context_file)
                        print(f"DEBUG-LEGACY: File context.txt trovato, dimensione: {file_size} bytes")
        
                        # Leggi l'intero contenuto del file
                        try:
                            with open(context_file, "r", encoding="utf-8") as f:
                                context_content = f.read()
            
                            self.add_log(f"‚úÖ File contesto letto: {len(context_content)} caratteri")
                            print(f"DEBUG-LEGACY: File contesto letto con successo: {len(context_content)} caratteri")
            
                            # Stampa le prime righe per debug
                            content_preview = context_content[:500].replace('\n', ' ')
                            print(f"DEBUG-LEGACY: Anteprima dei primi 500 caratteri: {content_preview}...")
            
                            # Analisi strutturale del contenuto per determinare il formato
                            print("DEBUG-LEGACY: Analisi strutturale del contenuto")
            
                            # Cerca sezioni nel formato standard
                            section_pattern = r'===\s+([^=]+?)\s+-\s+\d{8}_\d{6}\s+===\n'
                            sections = re.findall(section_pattern, context_content)
            
                            if sections:
                                print(f"DEBUG-LEGACY: Trovate {len(sections)} sezioni nel formato standard")
                                for i, section in enumerate(sections[:5]):  # Mostra solo le prime 5
                                    print(f"DEBUG-LEGACY: - Sezione {i+1}: {section}")
                
                                # Analisi dettagliata delle sezioni
                                print("DEBUG-LEGACY: Analisi dettagliata delle sezioni trovate")
                                section_contents = re.split(section_pattern, context_content)[1:]  # Salta il primo che √® vuoto
                
                                # Assicurati che abbiamo lo stesso numero di titoli e contenuti
                                if len(sections) == len(section_contents)/2:
                                    print("DEBUG-LEGACY: Numero corretto di sezioni e contenuti")
                                else:
                                    print(f"DEBUG-LEGACY: ATTENZIONE - Discrepanza: {len(sections)} titoli vs {len(section_contents)/2} contenuti")
                            else:
                                print("DEBUG-LEGACY: Nessuna sezione trovata nel formato standard")
                                # Cerca formati alternativi
                                alt_pattern = r'---\s+([^-]+?)\s+---\n'
                                alt_sections = re.findall(alt_pattern, context_content)
                                if alt_sections:
                                    print(f"DEBUG-LEGACY: Trovate {len(alt_sections)} sezioni in formato alternativo")
                                else:
                                    print("DEBUG-LEGACY: Nessuna sezione trovata in formato alternativo")
            
                            # ================ FASE 5B-1: ESTRAZIONE DATI LEGACY ================
                            try:
                                # ---------- Estrazione Titolo ----------
                                print("DEBUG-LEGACY: Tentativo estrazione titolo")
                
                                # Lista di pattern da provare per trovare il titolo
                                title_patterns = [
                                    r'7\)[^:]*:[^T]*Titolo[^:]*:[^\n]*\n([^\n]+)',
                                    r'7\.[^:]*:[^T]*Titolo[^:]*:[^\n]*\n([^\n]+)',
                                    r'Titolo[^:]*:[^\n]*\n([^\n]+)',
                                    r'(?:title|titolo)[^:]*:[^\n]*\n([^\n]+)',
                                    r'THE[^"]*"([^"]+)"',  # Pattern per titoli tra virgolette
                                    r'"([^"]+)".*?(?:il tuo nuovo libro|your new book)',  # Pattern per titoli suggeriti
                                ]
                
                                # Prova ogni pattern fino a trovare una corrispondenza
                                book_title_value = ""
                                for pattern in title_patterns:
                                    print(f"DEBUG-LEGACY: Provo pattern titolo: {pattern}")
                                    title_match = re.search(pattern, context_content, re.IGNORECASE)
                    
                                    if title_match:
                                        book_title_value = title_match.group(1).strip()
                                        self.add_log(f"‚úÖ Titolo estratto (legacy): {book_title_value}")
                                        print(f"DEBUG-LEGACY: Titolo estratto con pattern '{pattern}': {book_title_value}")
                                        break
                
                                if not book_title_value:
                                    print("DEBUG-LEGACY: Nessun titolo trovato con i pattern standard")
                    
                                    # Cerca titoli in sezioni specifiche
                                    print("DEBUG-LEGACY: Ricerca titolo in sezioni specifiche")
                    
                                    # Cerca sezioni che potrebbero contenere titoli
                                    title_sections = [s for s in sections if 'titolo' in s.lower() or 'title' in s.lower()]
                                    if title_sections:
                                        print(f"DEBUG-LEGACY: Trovate {len(title_sections)} sezioni potenzialmente contenenti titoli")
                        
                                        # Per ogni sezione potenziale, cerca titoli
                                        for title_section in title_sections:
                                            section_index = sections.index(title_section)
                                            section_content = section_contents[section_index * 2]  # Moltiplica per 2 a causa della divisione
                            
                                            # Cerca titoli nella sezione
                                            title_lines = [line for line in section_content.split('\n') if line.strip()]
                                            if title_lines:
                                                print(f"DEBUG-LEGACY: Sezione '{title_section}' contiene {len(title_lines)} linee non vuote")

    # Prendi la prima linea che sembra un titolo
                                            for line in title_lines:
                                                # Se la linea sembra un titolo (non troppo lungo, non contiene caratteri speciali)
                                                if 10 <= len(line) <= 100 and not any(char in line for char in ['{', '}', '(', ')', '[', ']']):
                                                    book_title_value = line.strip().strip('"\'')
                                                    print(f"DEBUG-LEGACY: Titolo estratto da sezione: {book_title_value}")
                                                    break
                            
                                            if book_title_value:
                                                break
                
                                # ---------- Estrazione Indice ----------
                                print("DEBUG-LEGACY: Tentativo estrazione indice")
                
                                # Lista di pattern da provare per trovare l'indice
                                index_patterns = [
                                    r'8\)[^:]*:[^I]*Indice[^:]*:[^\n]*\n(.*?)(?=\n\n|$)',
                                    r'8\.[^:]*:[^I]*Indice[^:]*:[^\n]*\n(.*?)(?=\n\n|$)',
                                    r'Indice[^:]*:[^\n]*\n(.*?)(?=\n\n|$)',
                                    r'(?:indice|index)[^:]*:[^\n]*\n(.*?)(?=\n\n|$)',
                                    r'INDICE DEL LIBRO[^\n]*\n(.*?)(?=\n\n===|$)',  # Pattern specifico
                                    r'Indice del Libro[^\n]*\n(.*?)(?=\n\n|$)'      # Altra variante
                                ]
                
                                # Prova ogni pattern fino a trovare una corrispondenza
                                book_index_value = ""
                                for pattern in index_patterns:
                                    print(f"DEBUG-LEGACY: Provo pattern indice: {pattern}")
                                    index_match = re.search(pattern, context_content, re.DOTALL | re.IGNORECASE)
                    
                                    if index_match:
                                        book_index_value = index_match.group(1).strip()
                                        self.add_log(f"‚úÖ Indice estratto (legacy): {len(book_index_value)} caratteri")
                                        print(f"DEBUG-LEGACY: Indice estratto con pattern '{pattern}', lunghezza: {len(book_index_value)}")
                                        print(f"DEBUG-LEGACY: Preview indice: {book_index_value[:200]}...")
                                        break
                
                                if not book_index_value:
                                    print("DEBUG-LEGACY: Nessun indice trovato con i pattern standard")
                                    print("DEBUG-LEGACY: Tentativo ricerca capitoli diretta")
                    
                                    # Cerca tutti i pattern che sembrano capitoli
                                    chapter_patterns = [
                                        r'(CAPITOLO\s+\d+[^:\n]*:[^\n]+)',
                                        r'(CHAPTER\s+\d+[^:\n]*:[^\n]+)',
                                        r'(Capitolo\s+\d+[^:\n]*:[^\n]+)'
                                    ]
                    
                                    all_chapters = []
                                    for pattern in chapter_patterns:
                                        chapters = re.findall(pattern, context_content, re.IGNORECASE)
                                        if chapters:
                                            print(f"DEBUG-LEGACY: Pattern '{pattern}' ha trovato {len(chapters)} capitoli")
                                            all_chapters.extend(chapters)
                    
                                    if all_chapters:
                                        print(f"DEBUG-LEGACY: Trovati {len(all_chapters)} capitoli potenziali nel testo")
                        
                                        # Cerca il blocco di testo che contiene pi√π capitoli consecutivi
                                        chapter_sections = []
                                        for match in re.finditer(r'((?:CAPITOLO\s+\d+[^\n]*\n){2,})', context_content, re.IGNORECASE):
                                            section_text = match.group(1)
                                            chapter_count = section_text.lower().count('capitolo')
                                            chapter_sections.append((match.start(), match.end(), section_text, chapter_count))
                        
                                        if chapter_sections:
                                            # Usa la sezione con pi√π capitoli
                                            best_section = max(chapter_sections, key=lambda x: x[3])
                                            print(f"DEBUG-LEGACY: Trovato blocco indice con {best_section[3]} capitoli")
                            
                                            # Aggiungi l'introduzione e conclusione se non presenti
                                            book_index_value = "INTRODUZIONE\n\n" + best_section[2] + "\nCONCLUSIONE"
                                            print(f"DEBUG-LEGACY: Indice costruito da blocco trovato: {len(book_index_value)} caratteri")
                                        else:
                                            # Se non ci sono blocchi, combina tutti i capitoli trovati
                                            book_index_value = "INTRODUZIONE\n\n" + "\n".join(all_chapters) + "\n\nCONCLUSIONE"
                                            print(f"DEBUG-LEGACY: Indice costruito da capitoli individuali: {len(book_index_value)} caratteri")
                
                                # ---------- Estrazione Stile di Voce ----------
                                print("DEBUG-LEGACY: Tentativo estrazione stile di voce")
                
                                # Lista di pattern da provare per trovare lo stile di voce
                                voice_patterns = [
                                    r'Tono di voce[^:]*:[^\n]*\n([^\n]+)',
                                    r'Voce[^:]*:[^\n]*\n([^\n]+)',
                                    r'Stile[^:]*:[^\n]*\n([^\n]+)',
                                    r'VOICE_STYLE[^:]*:[^\n]*\n([^\n]+)',
                                    r'(?:conversazionale|formale|informativo|tecnico)[^\n]+'
                                ]
                
                                # Prova ogni pattern fino a trovare una corrispondenza
                                voice_style_value = ""
                                for pattern in voice_patterns:
                                    print(f"DEBUG-LEGACY: Provo pattern stile voce: {pattern}")
                                    voice_match = re.search(pattern, context_content, re.IGNORECASE)
                    
                                    if voice_match:
                                        # Gestione speciale per l'ultimo pattern che non ha gruppo
                                        if 'conversazionale' in pattern:
                                            voice_style_value = voice_match.group(0).strip()
                                        else:
                                            voice_style_value = voice_match.group(1).strip()
                        
                                        self.add_log(f"‚úÖ Stile voce estratto (legacy): {voice_style_value}")
                                        print(f"DEBUG-LEGACY: Stile voce estratto con pattern '{pattern}': {voice_style_value}")
                                        break
                
                                if not voice_style_value:
                                    print("DEBUG-LEGACY: Nessuno stile di voce trovato con i pattern standard")
                    
                                    # Cerca nelle sezioni potenzialmente legate allo stile
                                    style_sections = [s for s in sections if any(term in s.lower() for term in 
                                                     ['voice', 'voce', 'stile', 'tone', 'tono'])]
                    
                                    if style_sections:
                                        print(f"DEBUG-LEGACY: Trovate {len(style_sections)} sezioni potenzialmente contenenti stile")
                        
                                        for style_section in style_sections:
                                            section_index = sections.index(style_section)
                                            section_content = section_contents[section_index * 2]
                            
                                            # Cerca stile nelle prime 5 righe della sezione
                                            style_lines = [line for line in section_content.split('\n')[:5] if line.strip()]
                                            if style_lines:
                                                voice_style_value = style_lines[0].strip()
                                                print(f"DEBUG-LEGACY: Stile voce estratto da sezione: {voice_style_value}")
                                                break
                
                                # ---------- Estrazione Tipo di Libro ----------
                                print("DEBUG-LEGACY: Tentativo estrazione tipo di libro")
                
                                # Lista di pattern da provare per trovare il tipo di libro
                                book_type_patterns = [
                                    r'tipo di libro[^:]*:[^\n]*\n*\s*([^\n]+)',
                                    r'genere[^:]*:[^\n]*\n*\s*([^\n]+)',
                                    r'categoria[^:]*:[^\n]*\n*\s*([^\n]+)',
                                    r'LIBRO_TIPO[^:]*:[^\n]*\n*\s*([^\n]+)'
                                ]
                
                                # Prova ogni pattern fino a trovare una corrispondenza
                                book_type_value = ""
                                for pattern in book_type_patterns:
                                    print(f"DEBUG-LEGACY: Provo pattern tipo libro: {pattern}")
                                    book_type_match = re.search(pattern, context_content, re.IGNORECASE)
                    
                                    if book_type_match:
                                        book_type_value = book_type_match.group(1).strip()
                                        self.add_log(f"‚úÖ Tipo di libro estratto (legacy): {book_type_value}")
                                        print(f"DEBUG-LEGACY: Tipo di libro estratto con pattern '{pattern}': {book_type_value}")
                                        break
                
                                if not book_type_value:
                                    print("DEBUG-LEGACY: Nessun tipo di libro trovato con i pattern standard")
                    
                                    # Cerca valori comuni di tipo libro nel testo
                                    common_types = ["Manuale", "Non-Fiction", "Ricettario", "Self-Help", "How-To", 
                                                   "Craft", "Hobby", "Survival", "Test Study"]
                    
                                    for book_type in common_types:
                                        if book_type.lower() in context_content.lower():
                                            book_type_value = book_type
                                            print(f"DEBUG-LEGACY: Tipo libro trovato nel testo: {book_type_value}")
                                            break
            
                            except Exception as extraction_error:
                                self.add_log(f"‚ö†Ô∏è Errore nell'estrazione dei dati: {str(extraction_error)}")
                                print(f"DEBUG-LEGACY: Errore nell'estrazione dei dati: {str(extraction_error)}")
                                print(f"DEBUG-LEGACY: Traceback errore estrazione:\n{traceback.format_exc()}")
            
                        except Exception as read_error:
                            self.add_log(f"‚ö†Ô∏è Errore nella lettura del file context.txt: {str(read_error)}")
                            print(f"DEBUG-LEGACY: Errore nella lettura del file context.txt: {str(read_error)}")
                            print(f"DEBUG-LEGACY: Traceback errore lettura:\n{traceback.format_exc()}")
            
                    else:
                        self.add_log("‚ö†Ô∏è File context.txt non trovato!")
                        print(f"DEBUG-LEGACY: File context.txt non trovato in {os.getcwd()}")
        
                        # Elenca i file nella directory corrente
                        files = os.listdir()
                        print(f"DEBUG-LEGACY: File nella directory corrente: {files}")
        
                        # Cerca file alternativi che potrebbero contenere i dati
                        context_alternatives = [f for f in files if 'context' in f.lower() or 
                                              'backup' in f.lower() or f.endswith('.txt')]
        
                        if context_alternatives:
                            print(f"DEBUG-LEGACY: Trovati possibili file alternativi: {context_alternatives}")
                            self.add_log(f"‚ö†Ô∏è File context.txt non trovato, ma ci sono alternative: {context_alternatives}")
    
                except Exception as e:
                    self.add_log(f"‚ö†Ô∏è Errore nell'estrazione legacy: {str(e)}")
                    print(f"DEBUG-LEGACY: Errore nell'estrazione legacy: {str(e)}")
                    print(f"DEBUG-LEGACY: Traceback errore estrazione:\n{traceback.format_exc()}")

            # ================ FASE 6: VALORI DI FALLBACK ================
            # Se necessario, utilizza valori di fallback per i campi che non √® stato possibile estrarre

            print("DEBUG-FINAL: Verifica valori estratti prima di applicare fallback")
            print(f"DEBUG-FINAL: Titolo estratto: '{book_title_value}'")
            print(f"DEBUG-FINAL: Indice estratto: {len(book_index_value) if book_index_value else 0} caratteri")
            print(f"DEBUG-FINAL: Stile voce estratto: '{voice_style_value}'")
            print(f"DEBUG-FINAL: Tipo libro estratto: '{book_type_value}'")

            # Applica fallback se necessario
            if not book_title_value:
                book_title_value = "Il tuo nuovo libro"
                self.add_log("‚ö†Ô∏è Usato titolo di fallback")
                print("DEBUG-FINAL: Usato titolo di fallback")

            if not book_index_value:
                book_index_value = """INTRODUZIONE

    CAPITOLO 1: Fondamenti

    CAPITOLO 2: Metodologia

    CAPITOLO 3: Applicazione

    CONCLUSIONE"""
                self.add_log("‚ö†Ô∏è Usato indice di fallback")
                print("DEBUG-FINAL: Usato indice di fallback")

            if not voice_style_value:
                voice_style_value = "Conversazionale e informativo"
                self.add_log("‚ö†Ô∏è Usato stile voce di fallback")
                print("DEBUG-FINAL: Usato stile voce di fallback")

            if not book_type_value:
                book_type_value = "Manuale (Non-Fiction)"
                self.add_log("‚ö†Ô∏è Usato tipo libro di fallback")
                print("DEBUG-FINAL: Usato tipo libro di fallback")

            # ================ FASE 7: AGGIORNAMENTO INTERFACCIA ================
            # Aggiorna i campi dell'interfaccia con i valori estratti

            print("DEBUG-UPDATE: Tentativo aggiornamento campi interfaccia")

            # Importa gradio esplicitamente se necessario
            import gradio as gr

            try:
                print("DEBUG-UPDATE: Inizio aggiornamento componenti Gradio")

                # Verifica e stampa info sulla versione di Gradio
                gradio_version = gr.__version__ if hasattr(gr, '__version__') else "sconosciuta"
                print(f"DEBUG-UPDATE: Versione Gradio rilevata: {gradio_version}")

                # Verifica quali componenti esistono
                components = {
                    'book_title': hasattr(self, 'book_title'),
                    'book_index': hasattr(self, 'book_index'),
                    'voice_style': hasattr(self, 'voice_style'),
                    'book_type_hidden': hasattr(self, 'book_type_hidden'),
                    'tabs': hasattr(self, 'tabs')
                }
                print(f"DEBUG-UPDATE: Componenti esistenti: {components}")

                # Per Gradio 5.x, il metodo corretto √® .update(value=...)

                if hasattr(self, 'book_title'):
                    print(f"DEBUG-UPDATE: Aggiornamento book_title: '{book_title_value}'")
                    self.book_title.update(value=book_title_value)
                    self.add_log(f"‚úì Campo book_title aggiornato")
                    print(f"DEBUG-UPDATE: Campo book_title aggiornato con: {book_title_value}")

                if hasattr(self, 'book_index'):
                    print(f"DEBUG-UPDATE: Aggiornamento book_index: {len(book_index_value)} caratteri")
                    self.book_index.update(value=book_index_value)  
                    self.add_log(f"‚úì Campo book_index aggiornato")
                    print(f"DEBUG-UPDATE: Campo book_index aggiornato (lunghezza: {len(book_index_value)} caratteri)")

                if hasattr(self, 'voice_style'):
                    print(f"DEBUG-UPDATE: Aggiornamento voice_style: '{voice_style_value}'")
                    self.voice_style.update(value=voice_style_value)
                    self.add_log(f"‚úì Campo voice_style aggiornato")
                    print(f"DEBUG-UPDATE: Campo voice_style aggiornato con: {voice_style_value}")

                # Aggiorna il tipo di libro se esiste il campo
                if hasattr(self, 'book_type_hidden'):
                    print(f"DEBUG-UPDATE: Aggiornamento book_type_hidden: '{book_type_value}'")
                    self.book_type_hidden.update(value=book_type_value)
                    self.add_log(f"‚úì Campo book_type_hidden aggiornato")
                    print(f"DEBUG-UPDATE: Campo book_type_hidden aggiornato con: {book_type_value}")

                # Cambia tab
                if hasattr(self, 'tabs'):
                    print("DEBUG-UPDATE: Aggiornamento tab a indice 2 (Generazione Libro)")
                    tabs_value = gr.Tabs(selected=2)  # Seleziona il tab "Generazione Libro"
                    self.add_log("‚úì Tab aggiornato")
                    print("DEBUG-UPDATE: Tab aggiornato a indice 2 (Generazione Libro)")
    
                # Verifica che Gradio abbia effettivamente aggiornato i campi
                print("DEBUG-UPDATE: Verifica finale campi aggiornati")
                if hasattr(self, 'book_title'):
                    print(f"DEBUG-UPDATE: book_title.value finale: {getattr(self.book_title, 'value', 'N/A')}")
    
            except Exception as ui_error:
                self.add_log(f"‚ö†Ô∏è Errore nell'aggiornamento UI: {str(ui_error)}")
                print(f"DEBUG-UPDATE: Errore nell'aggiornamento UI: {str(ui_error)}")
                print(f"DEBUG-UPDATE: Traceback errore UI:\n{traceback.format_exc()}")

                # Tentativo aggiornamento con metodo alternativo
                print("DEBUG-UPDATE: Tentativo metodo alternativo per aggiornamento UI")
                try:
                    # Prova con l'assegnazione diretta
                    if hasattr(self, 'book_title'):
                        try:
                            print("DEBUG-UPDATE: Tentativo assegnazione diretta a book_title.value")
                            self.book_title.value = book_title_value
                            print(f"DEBUG-UPDATE: Assegnazione diretta riuscita: {self.book_title.value}")
                        except Exception as direct_error:
                            print(f"DEBUG-UPDATE: Errore assegnazione diretta: {str(direct_error)}")
    
                    # Prova con setattr
                    if hasattr(self, 'book_index'):
                        try:
                            print("DEBUG-UPDATE: Tentativo con setattr per book_index")
                            setattr(self.book_index, "value", book_index_value)
                            print("DEBUG-UPDATE: setattr eseguito per book_index")
                        except Exception as setattr_error:
                            print(f"DEBUG-UPDATE: Errore con setattr: {str(setattr_error)}")
            
                except Exception as alt_error:
                    print(f"DEBUG-UPDATE: Anche il metodo alternativo fallito: {str(alt_error)}")

            # ================ FASE 8: COMPLETAMENTO ================
            self.add_log("‚úÖ Funzione complete_analysis terminata con successo")
            print("DEBUG-FINAL: Funzione complete_analysis terminata con successo")

            # Un ultimo check prima di restituire i valori
            print(f"DEBUG-FINAL: Valori finali da restituire:")
            print(f"DEBUG-FINAL: - Log history: {len(self.log_history)} righe")
            print(f"DEBUG-FINAL: - Status: {analysis_status_text}")
            print(f"DEBUG-FINAL: - Tabs: {tabs_value}")
            print(f"DEBUG-FINAL: - Titolo: {book_title_value}")
            print(f"DEBUG-FINAL: - Indice: {len(book_index_value)} caratteri")
            print(f"DEBUG-FINAL: - Stile: {voice_style_value}")
            print(f"DEBUG-FINAL: - Tipo: {book_type_value}")

            # ================ FASE 8.5: SALVATAGGIO NEL DATABASE ================
            try:
                # Estrai la keyword dall'analisi corrente
                keyword = None
                if hasattr(self, 'current_analysis') and self.current_analysis:
                    keyword = self.current_analysis.get('KEYWORD')
        
                # Se non abbiamo ancora una keyword, usa il titolo del libro
                if not keyword and book_title_value:
                    keyword = book_title_value.split(':')[0].strip()  # Prende la prima parte del titolo
        
                # Verifica che abbiamo una keyword da usare
                if keyword:
                    self.add_log(f"üíæ Tentativo salvataggio analisi nel database per keyword: {keyword}")
                    print(f"DEBUG-DB: Tentativo salvataggio con keyword: {keyword}")
        
                    try:
                        # Verifica che il database esista
                        if os.path.exists(self.crisp.project_db_path):
                            # Crea un nuovo progetto nel database
                            conn = sqlite3.connect(self.crisp.project_db_path)
                            cursor = conn.cursor()
                
                            # Crea un nuovo progetto
                            current_date = datetime.now().isoformat()
                            cursor.execute(
                                "INSERT INTO projects (name, creation_date, last_updated) VALUES (?, ?, ?)",
                                (f"Progetto {keyword}", current_date, current_date)
                            )
                            project_id = cursor.lastrowid
                
                            # Salva le variabili principali di progetto
                            main_vars = {
                                "KEYWORD": keyword,
                                "TITOLO_LIBRO": book_title_value,
                                "INDICE_LIBRO": book_index_value,
                                "VOICE_STYLE": voice_style_value,
                                "BOOK_TYPE": book_type_value
                            }
                
                            # Inserisci le variabili nel database
                            for key, value in main_vars.items():
                                if value:  # Salva solo valori non vuoti
                                    cursor.execute(
                                        "INSERT INTO project_variables (project_id, name, value) VALUES (?, ?, ?)",
                                        (project_id, key, str(value))
                                    )
                
                            # Se esistono dati in current_analysis, salvali come variabili
                            if hasattr(self, 'current_analysis') and self.current_analysis:
                                for key, value in self.current_analysis.items():
                                    if key not in main_vars and value:  # Evita duplicati
                                        cursor.execute(
                                            "INSERT INTO project_variables (project_id, name, value) VALUES (?, ?, ?)",
                                            (project_id, key, str(value))
                                        )
                
                            # Salva il contenuto del file di contesto come risultato di progetto
                            if hasattr(self.chat_manager, 'context_file') and os.path.exists(self.chat_manager.context_file):
                                with open(self.chat_manager.context_file, 'r', encoding='utf-8') as f:
                                    context_content = f.read()
                        
                                cursor.execute(
                                    "INSERT INTO project_results (project_id, prompt_id, created_at, data) VALUES (?, ?, ?, ?)",
                                    (project_id, "ANALISI", current_date, context_content)
                                )
                
                            conn.commit()
                            conn.close()
                
                            self.add_log(f"‚úÖ Analisi salvata con successo nel database (ID: {project_id})")
                            print(f"DEBUG-DB: Analisi salvata con successo, ID: {project_id}")
                        else:
                            self.add_log(f"‚ö†Ô∏è Database non trovato: {self.crisp.project_db_path}")
                            print(f"DEBUG-DB: Database non trovato: {self.crisp.project_db_path}")
                    except Exception as db_error:
                        self.add_log(f"‚ö†Ô∏è Errore durante il salvataggio nel database: {str(db_error)}")
                        print(f"DEBUG-DB: Errore salvataggio DB: {str(db_error)}")
                        print(f"DEBUG-DB: {traceback.format_exc()}")
                else:
                    self.add_log("‚ö†Ô∏è Impossibile salvare nel database: keyword non trovata")
                    print("DEBUG-DB: Impossibile salvare: keyword non trovata")
            except Exception as save_error:
                self.add_log(f"‚ö†Ô∏è Errore generale nel salvataggio: {str(save_error)}")
                print(f"DEBUG-DB: Errore generale nel salvataggio: {str(save_error)}")

            # ================ FASE 9: RESTITUZIONE VALORI ================
            # Restituzione esattamente 6 valori come richiesto dall'interfaccia
            return self.chat_manager.get_log_history_string(), analysis_status_text, tabs_value, book_title_value, book_index_value, voice_style_value

        except Exception as e:
            # Gestione errori globale - questo √® l'UNICO except per il try principale
            error_msg = f"‚ùå Errore durante il completamento dell'analisi: {str(e)}"
            self.add_log(error_msg)
            print(f"DEBUG-ERROR: ERRORE CRITICO in complete_analysis: {str(e)}")

            # Traceback completo dell'errore
            error_trace = traceback.format_exc()
            self.add_log(f"Dettagli errore:\n{error_trace}")
            print(f"DEBUG-ERROR: Traceback completo:\n{error_trace}")

            # Restituisci valori minimi in caso di errore critico
            print("DEBUG-ERROR: Restituzione valori di fallback a causa dell'errore")
            return self.chat_manager.get_log_history_string(), "**Stato analisi**: Errore", gr.Tabs(selected=0), "", "", ""
    
    
    def _complete_analysis_crisp(self):
        """Completa l'analisi CRISP 5.0"""
        try:
            self.add_log("Completamento analisi CRISP 5.0...")

            # Recupera l'ID del progetto CRISP corrente
            project_id = self.current_analysis.get('crisp_project_id')
            if not project_id:
                return self.add_log("Errore: Nessun progetto CRISP corrente trovato")

            # Recupera i dati completi del progetto
            project_data = self.crisp.get_project_data(project_id)

            # Aggiorna l'interfaccia con i dati estratti
            if hasattr(self, 'book_title') and 'TITOLO_LIBRO' in project_data:
                self.book_title.update(value=project_data['TITOLO_LIBRO'])

            if hasattr(self, 'book_language') and 'LINGUA' in project_data:
                self.book_language.update(value=project_data['LINGUA'])

            if hasattr(self, 'voice_style') and 'VOICE_STYLE' in project_data:
                self.voice_style.update(value=project_data['VOICE_STYLE'])

            # Costruisci l'indice del libro in base ai CONTENT_PILLARS
            if hasattr(self, 'book_index') and 'CONTENT_PILLARS' in project_data:
                # Estrai i pilastri di contenuto e trasformali in un indice
                pillars_text = project_data.get('CONTENT_PILLARS', '')
            
                # Cerca di estrarre i titoli dei pilastri
                pillars = []
                if isinstance(pillars_text, str):
                    # Cerca di estrarre i pilastri con regex
                    pillar_matches = re.findall(r'(\d+\.\s*[^\n]+)', pillars_text)
                    if pillar_matches:
                        pillars = [p.strip() for p in pillar_matches]
                    else:
                        # Alternativa: dividi per linee e filtra le linee non vuote
                        pillar_lines = [line.strip() for line in pillars_text.split('\n') if line.strip()]
                        pillars = pillar_lines[:5]  # Limita a 5 pilastri
            
                # Se abbiamo trovato dei pilastri, costruisci l'indice
                if pillars:
                    index_text = "INTRODUZIONE\n\n"
                    for i, pillar in enumerate(pillars, 1):
                        # Pulisci il pillar rimuovendo numeri e simboli iniziali
                        clean_pillar = re.sub(r'^\d+[\.\)\s]+', '', pillar).strip()
                        index_text += f"CAPITOLO {i}: {clean_pillar}\n"
                    index_text += "\nCONCLUSIONE"
                else:
                    # Indice di fallback se non troviamo pillars
                    index_text = "INTRODUZIONE\n\nCAPITOLO 1: Fondamenti\n\nCAPITOLO 2: Metodologia\n\nCAPITOLO 3: Applicazione\n\nCAPITOLO 4: Casi Studio\n\nCAPITOLO 5: Risultati\n\nCONCLUSIONE"
                
                self.book_index.update(value=index_text)
            
            # Mostra la sezione dei dettagli del libro
            if hasattr(self, 'book_details'):
                self.book_details.update(visible=True)
            
            # Crea un riepilogo dei dati estratti
            summary = f"""
            ===== ANALISI CRISP 5.0 COMPLETATA =====
        
            Titolo: {project_data.get('TITOLO_LIBRO', 'N/A')}
            Sottotitolo: {project_data.get('SOTTOTITOLO_LIBRO', 'N/A')}
        
            Angolo di Attacco: {project_data.get('ANGOLO_ATTACCO', 'N/A')}
            Big Idea: {project_data.get('BIG_IDEA', 'N/A')}
            Buyer Persona: {project_data.get('BUYER_PERSONA_SUMMARY', 'N/A')}
        
            Promessa Principale: {project_data.get('PROMESSA_PRINCIPALE', 'N/A')}
        
            L'interfaccia √® stata aggiornata con i dati del progetto.
            Puoi ora procedere con la generazione del libro.
            """
            
            # Salvataggio nel database
            try:
                self.add_log("üíæ Salvataggio dei risultati CRISP nel database...")
                
                # Il progetto √® gi√† salvato nel framework CRISP,
                # ma possiamo aggiungerlo anche al database generale per la visualizzazione
                if os.path.exists(self.crisp.project_db_path):
                    conn = sqlite3.connect(self.crisp.project_db_path)
                    cursor = conn.cursor()
                    
                    # Verifica se il progetto esiste gi√† nel database
                    cursor.execute("SELECT id FROM projects WHERE name = ?", (f"CRISP-{project_id}",))
                    existing = cursor.fetchone()
                    
                    if not existing:
                        # Crea una entry nel database principale
                        current_date = datetime.now().isoformat()
                        cursor.execute(
                            "INSERT INTO projects (name, creation_date, last_updated) VALUES (?, ?, ?)",
                            (f"CRISP-{project_id}", current_date, current_date)
                        )
                        
                        # Salva i principali metadati come variabili
                        db_project_id = cursor.lastrowid
                        
                        # Se il progetto √® stato salvato correttamente
                        if db_project_id:
                            # Salva keyword e altre informazioni chiave
                            keyword = project_data.get('KEYWORD', '')
                            cursor.execute(
                                "INSERT INTO project_variables (project_id, name, value) VALUES (?, ?, ?)",
                                (db_project_id, 'KEYWORD', keyword)
                            )
                            
                            # Salva riferimento al progetto CRISP originale
                            cursor.execute(
                                "INSERT INTO project_variables (project_id, name, value) VALUES (?, ?, ?)",
                                (db_project_id, 'CRISP_PROJECT_ID', str(project_id))
                            )
                            
                            # Registra avvenuto salvataggio
                            cursor.execute(
                                "INSERT INTO project_results (project_id, prompt_id, created_at, data) VALUES (?, ?, ?, ?)",
                                (db_project_id, "CRISP_SUMMARY", current_date, summary)
                            )
                            
                            conn.commit()
                            self.add_log(f"‚úÖ Riferimento al progetto CRISP salvato nel database principale (ID: {db_project_id})")
                    else:
                        self.add_log("‚ÑπÔ∏è Progetto CRISP gi√† presente nel database")
                    
                    conn.close()
            except Exception as db_error:
                self.add_log(f"‚ö†Ô∏è Errore durante il salvataggio nel database: {str(db_error)}")
                print(f"DEBUG-DB: Errore salvataggio DB: {str(db_error)}")           

            self.add_log(summary)
            return self.chat_manager.get_log_history_string()
            
        except Exception as e:
            error_msg = f"Errore durante il completamento dell'analisi CRISP 5.0: {str(e)}"
            self.add_log(error_msg)
            logging.error(error_msg)
            return self.chat_manager.get_log_history_string()

    
    def _complete_analysis_legacy(self):
        """Completa l'analisi legacy e mostra una finestra di dialogo per la selezione"""
        try:
            self.add_log("Completamento analisi legacy...")

            # 1. Recupera i dati dall'analisi salvata
            context_file = "context.txt"
    
            try:
                with open(context_file, "r", encoding="utf-8") as f:
                    full_text = f.read()
        
                # Estrai le diverse sezioni in base ai punti numerati
                # Cerca titoli e indici
                titoli_section = re.search(r'7\)\s+\*\*Titolo\s+&\s+sottotitolo[^F]*?FINE', full_text, re.DOTALL)
                indice_section = re.search(r'8\)\s+\*\*Indice\s+del\s+libro[^F]*?FINE', full_text, re.DOTALL)
        
                titoli_text = titoli_section.group(0) if titoli_section else ""
                indice_text = indice_section.group(0) if indice_section else ""
        
                # Estrai le opzioni di titolo
                titoli_options = []
                titoli_matches = re.finditer(r'(?:Opzione|Titolo)\s+\d+[:\)]\s+[""]?([^"\n]+)[""]?(?:\s*[:‚Äì-]\s*[""]?([^"\n]+)[""]?)?', titoli_text)
    
                for i, match in enumerate(titoli_matches, 1):
                    titolo = match.group(1).strip() if match.group(1) else ""
                    sottotitolo = match.group(2).strip() if match.group(2) else ""
                    if titolo:
                        titoli_options.append({
                            "id": i,
                            "titolo": titolo, 
                            "sottotitolo": sottotitolo,
                            "display": f"Opzione {i}: {titolo} - {sottotitolo}"
                        })
    
                # Estrai gli indici proposti
                indici_options = []
                indici_matches = re.finditer(r'(?:Indice|INDICE|CAPITOLI)[^\n]*\n(.*?)(?=\n\n|\n[A-Z]|$)', indice_text, re.DOTALL)
    
                for i, match in enumerate(indici_matches, 1):
                    indice_content = match.group(1).strip()
                    # Pulisci e formatta l'indice
                    indice_lines = [line.strip() for line in indice_content.split('\n') if line.strip()]
                    indice_formatted = "\n".join(indice_lines)
                    indici_options.append({
                        "id": i,
                        "content": indice_formatted,
                        "display": f"Indice {i}"
                    })
    
                # Estrai il tono di voce suggerito
                voice_style_match = re.search(r'(?:tono|stile|voce)[^:]*[:]\s*([^\n\.]+)', full_text, re.IGNORECASE)
                voice_style = voice_style_match.group(1).strip() if voice_style_match else "Conversazionale"
    
                # Salva temporaneamente le opzioni per l'uso nella finestra di dialogo
                self.temp_titles = titoli_options
                self.temp_indices = indici_options
                self.temp_voice_style = voice_style
            
                # Log delle opzioni
                self.add_log("\n=== OPZIONI DI SELEZIONE ===")
                self.add_log(f"Titoli disponibili: {len(titoli_options)}")
                for t in titoli_options:
                    self.add_log(f"- {t['display']}")
                
                self.add_log(f"Indici disponibili: {len(indici_options)}")
                for idx in indici_options:
                    preview = idx['content'][:50] + "..." if len(idx['content']) > 50 else idx['content']
                    self.add_log(f"- Indice {idx['id']}: {preview}")
                
                self.add_log(f"Stile di voce: {voice_style}")
            
                # Crea una finestra di dialogo per la selezione
                self.create_selection_dialog(titoli_options, indici_options, voice_style)
            
                return self.chat_manager.get_log_history_string()
    
            except Exception as e:
                self.add_log(f"‚ö†Ô∏è Errore nell'analisi del contesto: {str(e)}")
                import traceback
                self.add_log(traceback.format_exc())
                return self.chat_manager.get_log_history_string()

                # Salvataggio nel database
                try:
                    # Estrai keyword dal contesto o dal titolo
                    keyword = None
                    
                    # Cerca la keyword nel testo
                    keyword_match = re.search(r'(?:keyword|parola chiave)[^:]*?:\s*([^\n]+)', full_text, re.IGNORECASE)
                    if keyword_match:
                        keyword = keyword_match.group(1).strip()
                    
                    # Se non trovata, usa il titolo della prima opzione
                    if not keyword and titoli_options:
                        keyword = titoli_options[0]['titolo'].split()[0]  # Prima parola del primo titolo
                    
                    # Se abbiamo una keyword, salva nel database
                    if keyword:
                        self.add_log(f"üíæ Salvataggio analisi legacy nel database per keyword: {keyword}")
                        
                        if os.path.exists(self.crisp.project_db_path):
                            conn = sqlite3.connect(self.crisp.project_db_path)
                            cursor = conn.cursor()
                            
                            # Crea un nuovo progetto
                            current_date = datetime.now().isoformat()
                            cursor.execute(
                                "INSERT INTO projects (name, creation_date, last_updated) VALUES (?, ?, ?)",
                                (f"Legacy-{keyword}", current_date, current_date)
                            )
                            project_id = cursor.lastrowid
                            
                            # Salva la keyword
                            cursor.execute(
                                "INSERT INTO project_variables (project_id, name, value) VALUES (?, ?, ?)",
                                (project_id, "KEYWORD", keyword)
                            )
                            
                            # Salva le opzioni di titolo
                            if titoli_options:
                                title_json = json.dumps(titoli_options)
                                cursor.execute(
                                    "INSERT INTO project_variables (project_id, name, value) VALUES (?, ?, ?)",
                                    (project_id, "TITLE_OPTIONS", title_json)
                                )
                            
                            # Salva le opzioni di indice
                            if indici_options:
                                index_json = json.dumps(indici_options)
                                cursor.execute(
                                    "INSERT INTO project_variables (project_id, name, value) VALUES (?, ?, ?)",
                                    (project_id, "INDEX_OPTIONS", index_json)
                                )
                            
                            # Salva il tono di voce
                            if voice_style:
                                cursor.execute(
                                    "INSERT INTO project_variables (project_id, name, value) VALUES (?, ?, ?)",
                                    (project_id, "VOICE_STYLE", voice_style)
                                )
                            
                            # Salva il testo completo
                            cursor.execute(
                                "INSERT INTO project_results (project_id, prompt_id, created_at, data) VALUES (?, ?, ?, ?)",
                                (project_id, "ANALISI_LEGACY", current_date, full_text)
                            )
                            
                            conn.commit()
                            conn.close()
                            
                            self.add_log(f"‚úÖ Analisi legacy salvata nel database (ID: {project_id})")
                    else:
                        self.add_log("‚ö†Ô∏è Impossibile salvare nel database: keyword non trovata")
                except Exception as db_error:
                    self.add_log(f"‚ö†Ô∏è Errore durante il salvataggio nel database: {str(db_error)}")
                    import traceback
                    self.add_log(traceback.format_exc())

        except Exception as e:
            error_msg = f"Errore durante il completamento dell'analisi: {str(e)}"
            self.add_log(error_msg)
            logging.error(error_msg)
            return self.chat_manager.get_log_history_string()

    def create_selection_dialog(self, titoli_options, indici_options, voice_style):
        """Crea una finestra di dialogo per selezionare titolo, indice e stile di voce"""
        import gradio as gr

        # Verifica che ci siano opzioni da mostrare
        if not titoli_options:
            titoli_options = [{"id": 1, "titolo": "Il tuo nuovo libro", "sottotitolo": "", "display": "Titolo predefinito"}]
        if not indici_options:
            indici_options = [{"id": 1, "content": "INTRODUZIONE\n\nCAPITOLO 1: Fondamenti\n\nCAPITOLO 2: Metodologia\n\nCAPITOLO 3: Applicazione\n\nCONCLUSIONE", "display": "Indice predefinito"}]

        # Creazione interfaccia di selezione
        with gr.Blocks(title="Selezione Opzioni") as selection_interface:
            with gr.Row():
                gr.Markdown("## Seleziona le opzioni per il tuo libro")
        
            # Titolo
            with gr.Row():
                with gr.Column(scale=3):
                    gr.Markdown("### Seleziona un titolo")
                    title_radio = gr.Radio(
                        choices=[t["display"] for t in titoli_options],
                        label="Titoli disponibili",
                        value=titoli_options[0]["display"] if titoli_options else None
                    )
            
                with gr.Column(scale=1):
                    gr.Markdown("### Anteprima")
                    title_preview = gr.Textbox(
                        label="Titolo selezionato",
                        value=titoli_options[0]["titolo"] if titoli_options else "",
                        interactive=False
                    )
                    subtitle_preview = gr.Textbox(
                        label="Sottotitolo",
                        value=titoli_options[0]["sottotitolo"] if titoli_options else "",
                        interactive=False
                    )
        
            # Indice
            with gr.Row():
                with gr.Column(scale=1):
                    gr.Markdown("### Seleziona un indice")
                    index_radio = gr.Radio(
                        choices=[idx["display"] for idx in indici_options],
                        label="Indici disponibili",
                        value=indici_options[0]["display"] if indici_options else None
                    )
            
                with gr.Column(scale=2):
                    gr.Markdown("### Anteprima indice")
                    index_preview = gr.TextArea(
                        label="Indice selezionato",
                        value=indici_options[0]["content"] if indici_options else "",
                        interactive=False,
                        lines=10
                    )
        
            # Stile di voce
            with gr.Row():
                voice_style_input = gr.Textbox(
                    label="Stile di voce",
                    value=voice_style,
                    interactive=True
                )
        
            # Pulsanti azione
            with gr.Row():
                confirm_btn = gr.Button("Conferma selezione", variant="primary")
                cancel_btn = gr.Button("Annulla", variant="secondary")
        
            # Funzioni di callback
            def update_title_preview(title_display):
                for t in titoli_options:
                    if t["display"] == title_display:
                        return t["titolo"], t["sottotitolo"]
                return "", ""
        
            def update_index_preview(index_display):
                for idx in indici_options:
                    if idx["display"] == index_display:
                        return idx["content"]
                return ""
        
            def confirm_selection(title_display, index_display, voice_style):
                # Trova il titolo selezionato
                selected_title = ""
                selected_subtitle = ""
                for t in titoli_options:
                    if t["display"] == title_display:
                        selected_title = t["titolo"]
                        selected_subtitle = t["sottotitolo"]
                        break
            
                # Trova l'indice selezionato
                selected_index = ""
                for idx in indici_options:
                    if idx["display"] == index_display:
                        selected_index = idx["content"]
                        break
            
                # Aggiorna i campi nella scheda di generazione del libro
                full_title = f"{selected_title}" + (f" - {selected_subtitle}" if selected_subtitle else "")
            
                # Aggiorna i campi dell'interfaccia principale
                if hasattr(self, 'book_title'):
                    self.book_title.update(value=full_title)
            
                if hasattr(self, 'book_index'):
                    self.book_index.update(value=selected_index)
            
                if hasattr(self, 'voice_style'):
                    self.voice_style.update(value=voice_style)
            
                self.add_log(f"‚úÖ Selezione confermata: Titolo='{full_title}', Stile='{voice_style}'")
            
                # Chiudi la finestra di dialogo
                return gr.update(visible=False)
        
            def cancel_selection():
                # Usa i valori predefiniti
                default_title = titoli_options[0]["titolo"] + " - " + titoli_options[0]["sottotitolo"] if titoli_options else "Il tuo nuovo libro"
                default_index = indici_options[0]["content"] if indici_options else "INTRODUZIONE\n\nCAPITOLO 1: Fondamenti\n\nCAPITOLO 2: Metodologia\n\nCAPITOLO 3: Applicazione\n\nCONCLUSIONE"
            
                # Aggiorna i campi nella scheda di generazione del libro
                if hasattr(self, 'book_title'):
                    self.book_title.update(value=default_title)
            
                if hasattr(self, 'book_index'):
                    self.book_index.update(value=default_index)
            
                if hasattr(self, 'voice_style'):
                    self.voice_style.update(value=voice_style)
            
                self.add_log("‚ö†Ô∏è Selezione annullata, usati valori predefiniti")
            
                # Chiudi la finestra di dialogo
                return gr.update(visible=False)
        
            # Connessione dei callback
            title_radio.change(
                fn=update_title_preview,
                inputs=[title_radio],
                outputs=[title_preview, subtitle_preview]
            )
        
            index_radio.change(
                fn=update_index_preview,
                inputs=[index_radio],
                outputs=[index_preview]
            )
        
            confirm_btn.click(
                fn=confirm_selection,
                inputs=[title_radio, index_radio, voice_style_input],
                outputs=[selection_interface]
            )
        
            cancel_btn.click(
                fn=cancel_selection,
                outputs=[selection_interface]
            )
    
        # Lancia l'interfaccia in una nuova finestra
        selection_interface.launch(inbrowser=True, prevent_thread_lock=True)
        self.add_log("üîç Finestra di selezione aperta. Scegli le opzioni desiderate.")

    def handle_selection_result(self, title_display, index_display, voice_style):
        """Gestisce il risultato della selezione dalla finestra di dialogo"""
        try:
            title_id = None
            index_id = None
        
            # Trova l'ID del titolo selezionato
            for t in self.temp_titles:
                if t["display"] == title_display:
                    title_id = t["id"]
                    break
        
            # Trova l'ID dell'indice selezionato
            for idx in self.temp_indices:
                if idx["display"] == index_display:
                    index_id = idx["id"]
                    break
        
            # Aggiorna i campi nella scheda di generazione del libro
            if title_id is not None:
                selected_title = next((t for t in self.temp_titles if t["id"] == title_id), None)
                if selected_title:
                    full_title = f"{selected_title['titolo']}" + (f" - {selected_title['sottotitolo']}" if selected_title['sottotitolo'] else "")
                    self.book_title.update(value=full_title)
        
            if index_id is not None:
                selected_index = next((idx for idx in self.temp_indices if idx["id"] == index_id), None)
                if selected_index:
                    self.book_index.update(value=selected_index["content"])
        
            # Aggiorna lo stile di voce
            self.voice_style.update(value=voice_style)
        
            self.add_log(f"‚úÖ Selezione applicata alla scheda di generazione del libro")
            return True
        
        except Exception as e:
            self.add_log(f"‚ùå Errore nell'applicazione della selezione: {str(e)}")
            return False
    
    def _generate_book_crisp(self, book_title, book_language, voice_style, book_index):
        """
        Genera il libro usando il framework CRISP 5.0.
    
        Args:
            book_title: Titolo del libro
            book_language: Lingua del libro
            voice_style: Stile narrativo
            book_index: Indice del libro
        
        Returns:
            str: Log dell'operazione
        """
        try:
            if not book_title.strip():
                return self.add_log("Errore: Il titolo del libro √® obbligatorio!")
            if not book_index.strip():
                return self.add_log("Errore: L'indice del libro √® obbligatorio!")
        
            self.add_log(f"Avvio generazione libro CRISP 5.0: {book_title}")
        
            # Recupera l'ID del progetto CRISP corrente
            project_id = self.current_analysis.get('crisp_project_id')
            if not project_id:
                return self.add_log("Errore: Nessun progetto CRISP corrente trovato")
        
            # Recupera i dati completi del progetto
            project_data = self.crisp.get_project_data(project_id)
        
            # Aggiorna i dati del progetto con le informazioni correnti
            project_data.update({
                "TITOLO_LIBRO": book_title,
                "LINGUA_LIBRO": book_language,
                "VOICE_STYLE": voice_style,
                "INDICE_LIBRO": book_index
            })
        
            # Aggiorna i dati nel database CRISP
            self.crisp._save_result_to_db(
                project_id,
                "GEN1",
                f"Generazione libro: {book_title}",
                {
                    "TITOLO_LIBRO": book_title,
                    "LINGUA_LIBRO": book_language,
                    "VOICE_STYLE": voice_style,
                    "INDICE_LIBRO": book_index
                }
            )
        
            # Dividi l'indice in capitoli
            chapters = [line.strip() for line in book_index.split('\n') if line.strip()]
        
            # Filtra per mantenere solo le righe che sembrano capitoli
            chapter_pattern = re.compile(r'(CAPITOLO|CHAPTER|PARTE|PART|SEZIONE|SECTION)\s*\d*\s*[:\.\-‚Äì‚Äî]?\s*(.*)', re.IGNORECASE)
            filtered_chapters = []
        
            for line in chapters:
                match = chapter_pattern.match(line)
                if match:
                    chapter_title = match.group(2).strip()
                    if chapter_title:  # Assicurati che il titolo non sia vuoto
                        filtered_chapters.append(chapter_title)
                elif not any(keyword.lower() in line.lower() for keyword in ['introduzione', 'introduction', 'conclusione', 'conclusion']):
                    # Includi anche le righe che non contengono parole chiave specifiche
                    filtered_chapters.append(line)
        
            # Se non abbiamo trovato capitoli validi, usa le righe originali
            if not filtered_chapters:
                filtered_chapters = [line for line in chapters if line.strip()]
        
            # Prepara la risposta cumulativa
            book_content = []
        
            # Aggiungi introduzione se non √® gi√† nei capitoli
            has_intro = any('introduz' in chapter.lower() or 'introduct' in chapter.lower() for chapter in filtered_chapters)
            if not has_intro:
                book_content.append("# Introduzione\n\n[Introduzione del libro]")
        
            # Genera ciascun capitolo
            for i, chapter_title in enumerate(filtered_chapters):
                self.add_log(f"Generazione capitolo {i+1}/{len(filtered_chapters)}: {chapter_title}")
            
                # Prepara il prompt per il capitolo, sfruttando i dati CRISP
                chapter_prompt = f"""
                Scrivi il capitolo "{chapter_title}" per il libro "{book_title}" usando lo stile: {voice_style}.
            
                Il libro √® posizionato come "{project_data.get('ANGOLO_ATTACCO', '')}" 
                e rivolto a {project_data.get('BUYER_PERSONA_SUMMARY', 'lettori interessati a questo argomento')}.
            
                L'idea centrale (Big Idea) del libro √®: {project_data.get('BIG_IDEA', 'Non specificata')}
            
                I pilastri di contenuto principali sono:
                {project_data.get('CONTENT_PILLARS', 'Non specificati')}
            
                Il metodo proprietario presentato nel libro √®:
                {project_data.get('PROPRIETARY_METHOD', 'Non specificato')}
            
                Il capitolo deve essere dettagliato, coinvolgente e allineato con gli obiettivi generali del libro.
                Lunghezza minima: 1500 parole.
            
                Includi:
                - Un'introduzione coinvolgente
                - Sezioni dettagliate sul tema
                - Esempi pratici e applicabili
                - Una conclusione che riassume i punti chiave
            
                Scrivi SOLO il contenuto del capitolo, senza includere "Capitolo X" o il titolo.
            
                Termina con la parola FINE quando il capitolo √® completato.
                """
            
                # Invia il prompt a Genspark
                try:
                    # Ottieni input box
                    input_box = WebDriverWait(self.driver, 10).until(
                        EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper textarea"))
                    )
                
                    # Pulisci l'input box
                    input_box.clear()
                    time.sleep(0.5)
                
                    # Inserisci il testo
                    input_box.send_keys(chapter_prompt)
                    time.sleep(1)
                
                    # Trova e clicca il pulsante di invio
                    send_button = WebDriverWait(self.driver, 10).until(
                        EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper div.input-icon"))
                    )
                    send_button.click()
                
                    # Attendi risposta
                    self.add_log("‚è≥ Attesa risposta per il capitolo...")
                
                    # Verifica completamento risposta
                    last_length = 0
                    stable_count = 0
                    max_stable_counts = 2
                    chapter_content = None
                
                    for attempt in range(60):  # Max 10 minuti (60 * 10 secondi)
                        time.sleep(10)
                        response = self.get_last_response()
                    
                        if response:
                            current_length = len(response)
                        
                            if current_length == last_length:
                                stable_count += 1
                                if stable_count >= max_stable_counts:
                                    # Risposta stabile
                                    chapter_content = response
                                    break
                            else:
                                stable_count = 0
                                last_length = current_length
                
                    if not chapter_content:
                        raise Exception(f"Timeout in attesa della risposta per il capitolo {chapter_title}")
                
                    # Rimuovi la parola FINE se presente
                    if "FINE" in chapter_content:
                        chapter_content = chapter_content[:chapter_content.find("FINE")].strip()
                
                    # Aggiungi il titolo e il contenuto al libro
                    formatted_chapter = f"# {chapter_title}\n\n{chapter_content}"
                    book_content.append(formatted_chapter)
                
                    # Salva il capitolo nel database CRISP
                    self.crisp._save_result_to_db(
                        project_id,
                        f"CAP{i+1}",
                        formatted_chapter,
                        {"chapter_title": chapter_title}
                    )
                
                    self.add_log(f"‚úÖ Capitolo {i+1} completato: {chapter_title}")
                
                    # Gestisci il reset del contesto se necessario
                    if attempt % 2 == 0:  # Ogni 2 capitoli
                        self.handle_context_limit()
            
                except Exception as e:
                    error_msg = f"Errore durante la generazione del capitolo {chapter_title}: {str(e)}"
                    self.add_log(error_msg)
                    logging.error(error_msg)
                    book_content.append(f"# {chapter_title}\n\nErrore durante la generazione di questo capitolo: {str(e)}")
            
                # Breve pausa tra i capitoli
                time.sleep(5)
        
            # Aggiungi conclusione se non √® gi√† nei capitoli
            has_conclusion = any('conclus' in chapter.lower() or 'conclusion' in chapter.lower() for chapter in filtered_chapters)
            if not has_conclusion:
                book_content.append("# Conclusione\n\n[Conclusione del libro]")
        
            # Unisci tutti i capitoli
            complete_book = "\n\n".join(book_content)
        
            # Salva il libro in un file
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            book_filename = f"book_{timestamp}.md"
            with open(book_filename, "w", encoding="utf-8") as f:
                f.write(complete_book)
        
            # Salva anche nel database CRISP
            self.crisp._save_result_to_db(
                project_id,
                "COMPLETE_BOOK",
                complete_book,
                {
                    "title": book_title,
                    "language": book_language,
                    "style": voice_style,
                    "chapters": len(filtered_chapters),
                    "filename": book_filename
                }
            )
        
            self.add_log(f"üìö Libro generato e salvato come: {book_filename}")
            return self.chat_manager.get_log_history_string()
        
        except Exception as e:
            error_msg = f"Errore durante la generazione del libro CRISP 5.0: {str(e)}"
            self.add_log(error_msg)
            logging.error(error_msg)
            return self.chat_manager.get_log_history_string()
    
    def _generate_book_legacy(self, book_title, book_language, voice_style, book_index):
        """Metodo legacy per generare il libro"""
        try:
            if not book_title.strip():
                return self.add_log("Errore: Il titolo del libro √® obbligatorio!")
            if not book_index.strip():
                return self.add_log("Errore: L'indice del libro √® obbligatorio!")
            
            self.add_log(f"Generazione libro: {book_title}")
            # Qui andr√† il codice per la generazione del libro legacy
            # Poich√© non era fornito nell'originale, lasciamo un placeholder
            self.add_log("‚úÖ Libro generato")
            return self.chat_manager.get_log_history_string()
            
        except Exception as e:
            error_msg = f"Errore durante la generazione del libro: {str(e)}"
            self.add_log(error_msg)
            logging.error(error_msg)
            return self.chat_manager.get_log_history_string()
    
    def split_prompt(self, text, prompt_id=None, section_number=None):
        """
        Divide il prompt in sezioni numeriche mantenendo l'integrit√†.
        Aggiunto tracciamento della posizione nel flusso.
        """
        # Log della posizione corrente
        location = f"Prompt {section_number if section_number else 'unknown'} di {prompt_id if prompt_id else 'unknown'}"
        self.add_log(f"DEBUG_LOCATION: Analisi in {location}")

        # Prima pulizia: rimuovi eventuali risposte precedenti
        if "PROMPT ------" in text:
            text = text.split("PROMPT ------")[1].split("------ END PROMPT")[0].strip()
            self.add_log(f"DEBUG_CLEAN: Estratto contenuto prompt pulito in {location}")

        sections = []
        # Usa regex per trovare sezioni che iniziano con numero e punto
        section_matches = re.finditer(r'(?:^|\n)\s*(\d+)\.\s+(.*?)(?=(?:\n\s*\d+\.|$))', text, re.DOTALL)
    
        for match in section_matches:
            section_num = match.group(1)
            section_content = match.group(2).strip()
            if section_content:
                sections.append(f"{section_num}. {section_content}")
                self.add_log(f"DEBUG_SECTION: Trovata sezione {section_num} in {location}")
                self.add_log(f"DEBUG_CONTENT: Primi 100 caratteri: {section_content[:100]}...")
    
        # Se non trova sezioni numerate, restituisci il testo intero
        if not sections:
            self.add_log(f"DEBUG_WARNING: Nessuna sezione numerata trovata in {location}")
            return [text]
        
        self.add_log(f"DEBUG_SUMMARY: Trovate {len(sections)} sezioni numerate valide in {location}")
    
        # Verifica contenuto per possibili errori
        for i, section in enumerate(sections):
            if "BSR medio" in section or "Competitivit√†:" in section:
                self.add_log(f"DEBUG_ERROR: Possibile contenuto di risposta trovato nella sezione {i+1} di {location}")
                self.add_log(f"DEBUG_CONTENT_ERROR: {section[:200]}...")
    
        return sections

    def send_to_genspark(self, text, prompt_id=None, section_number=None):
        """
        Invia un messaggio a Genspark e attende la risposta.
        Versione completamente rivista per garantire stabilit√† e affidabilit√†,
        con aggiornamento dell'interfaccia utente integrato.
        """
        # Aggiungi informazioni sul numero della domanda/prompt
        question_number = None
        if text and text.strip():
            # Cerca un pattern come "1)" o "2." all'inizio del testo
            match = re.match(r'^\s*(\d+)[\.|\)]', text)
            if match:
                question_number = match.group(1)
                self.add_log(f"‚öôÔ∏è Elaborazione domanda #{question_number}")

        self.cooldown_manager.track_request()

        # Log iniziale con posizione nel flusso
        location = self.log_prompt_location(
            prompt_id or "unknown",
            section_number or "unknown",
            f"Invio testo ({len(text)} caratteri)"
        )

        # Log di debug per tracciare l'esecuzione
        print(f"DEBUG: send_to_genspark chiamato - prompt_id: {prompt_id}, section_number: {section_number}")
        print(f"DEBUG: Lunghezza testo da inviare: {len(text)} caratteri")
        print(f"DEBUG: Anteprima testo: {text[:150].replace(chr(10), ' ')}...")

        # Funzione helper interna per aggiornare UI e restituire la risposta
        def update_ui_and_return(response, success=True, message=None):
            """Helper interno per aggiornare UI e tornare la risposta"""
            # Debug della risposta
            if response:
                print(f"DEBUG: Salvataggio risposta - Lunghezza: {len(response)}")
                print(f"DEBUG: Preview risposta: {response[:200].replace(chr(10), ' ')}...")
            
                # Controlla se la risposta contiene FINE o FINE_RISPOSTA
                has_end = "FINE_RISPOSTA" in response or "FINE" in response
                print(f"DEBUG: Risposta contiene terminatore: {has_end}")
            
                # Se la risposta √® completa, salvala nel file di contesto
                if hasattr(self, 'chat_manager'):
                    print(f"DEBUG: Chiamata a chat_manager.save_response per {location}")
                    metadata = {
                        "prompt_id": prompt_id,
                        "section_number": section_number,
                        "timestamp": datetime.now().strftime('%Y%m%d_%H%M%S'),
                        "has_terminator": has_end
                    }
                    # Verifica se il file di contesto esiste prima di salvare
                    context_file = getattr(self.chat_manager, 'context_file', 'context.txt')
                    print(f"DEBUG: Verifica file context.txt - Esiste: {os.path.exists(context_file)}")
                
                    # Salva la risposta
                    try:
                        self.chat_manager.save_response(response, f"Prompt {prompt_id}-{section_number}", metadata)
                        print(f"DEBUG: Risposta salvata con successo in {context_file}")
                    except Exception as save_error:
                        print(f"DEBUG: ERRORE durante il salvataggio della risposta: {str(save_error)}")
                        import traceback
                        print(f"DEBUG: Traceback salvataggio:\n{traceback.format_exc()}")
            else:
                print("DEBUG: Risposta vuota o None")
            
            if hasattr(self, 'results_display') and response:
                try:
                    # Per risposte brevi o in caso di errore, formattazione semplice
                    if len(response) < 2000 or not success:
                        status_class = "bg-green-50 border-green-500" if success else "bg-red-50 border-red-500"
                        status_text = "Risposta completata" if success else f"Errore: {message or 'Vedi dettagli nel log'}"
                
                        html_response = f"""
                        <div class="{status_class} border-l-4 p-3 mb-3 rounded">
                            <div class="flex justify-between">
                                <div><strong>{status_text}</strong></div>
                                <div>{len(response)} caratteri</div>
                            </div>
                        </div>
                        <div class="results-content p-4 bg-white rounded-lg border border-gray-200">
                            <pre style="white-space: pre-wrap; font-family: monospace;">{response}</pre>
                        </div>
                        """
                    else:
                        # Per risposte lunghe, mostra anteprima e aggiungi opzione per vedere tutto
                        preview = response[:1000] + "..." 
                        html_response = f"""
                        <div class="bg-green-50 border-l-4 border-green-500 p-3 mb-3 rounded">
                            <div class="flex justify-between">
                                <div><strong>Risposta completata</strong></div>
                                <div>{len(response)} caratteri</div>
                            </div>
                        </div>
                        <div class="results-preview p-4 bg-white rounded-lg border border-gray-200">
                            <pre style="white-space: pre-wrap; font-family: monospace; max-height: 300px; overflow-y: auto;">{preview}</pre>
                            <div class="mt-2 text-center">
                                <em class="text-gray-500">Risposta completa salvata - Clicca "Completa Analisi" per vedere i risultati formattati</em>
                            </div>
                        </div>
                        """
            
                    self.results_display.update(value=html_response)
                    self.add_log(f"‚úÖ Interfaccia aggiornata con risposta di {len(response)} caratteri")
                    print(f"DEBUG: UI aggiornata con risposta di {len(response)} caratteri")
                except Exception as ui_error:
                    self.add_log(f"‚ùå Errore nell'aggiornamento dell'interfaccia: {str(ui_error)}")
                    print(f"DEBUG: Errore nell'aggiornamento UI: {str(ui_error)}")
    
            return response

        # Log iniziale con stack trace per debugging
        import traceback
        call_stack = traceback.format_stack()
        stack_info = "\n".join(call_stack[-5:])

        self.add_log(f"üîç [{location}] Inizio invio prompt")
        self.add_log(f"üîç Inizio invio prompt ({len(text)} caratteri) in {location}")

        # Verifica che il browser sia attivo
        if not hasattr(self, 'driver') or self.driver is None:
            self.add_log("‚ö†Ô∏è Browser non attivo, inizializzazione...")
            self.driver = setup_browser()
            self.driver.get("https://genspark.ai")
            time.sleep(10)  # Attesa pi√π lunga per l'inizializzazione
    
            # Verifica login solo alla prima apertura
            if not check_login(self.driver):
                self.add_log("‚ö†Ô∏è Login necessario")
                return update_ui_and_return("ERRORE: Login necessario", success=False, message="Login necessario")

        # Verifica URL corrente solo se non siamo gi√† in una chat
        current_url = self.driver.current_url
        if "genspark.ai" not in current_url and "/agents" not in current_url and "/chat" not in current_url:
            self.add_log("üîÑ Navigazione a Genspark necessaria...")
            self.driver.get("https://genspark.ai")
            time.sleep(10)

        # Usa il nuovo metodo di divisione del prompt
        sections = self.split_prompt(text)

        # DEBUG AGGIUNTIVO - INIZIO
        sections_count = len(sections)
        self.add_log(f"üìã Prompt diviso in {sections_count} sezioni numerate")
        print(f"DEBUG: Prompt diviso in {sections_count} sezioni")
        for i, section in enumerate(sections):
            self.add_log(f"üìÑ Sezione {i+1}: {section[:50]}..." + ("" if len(section) <= 50 else f" ({len(section)} caratteri)"))
            print(f"DEBUG: Sezione {i+1}: {section[:50].replace(chr(10), ' ')}...")

        # Prendi solo la prima sezione per l'invio corrente
        section_to_send = sections[0] if sections else text

        # Verifica che il browser sia attivo
        if not hasattr(self, 'driver') or self.driver is None:
            self.add_log("‚ö†Ô∏è Browser non attivo, inizializzazione...")
            self.driver = setup_browser()
            self.driver.get("https://genspark.ai")
            time.sleep(10)  # Attesa pi√π lunga per l'inizializzazione

        try:
            # Verifico URL corrente per debugging
            current_url = self.driver.current_url
            self.add_log(f"üåê URL corrente: {current_url}")
            print(f"DEBUG: URL corrente: {current_url}")

            # Se non siamo in una pagina di chat, naviga a Genspark
            if "genspark.ai" not in current_url:
                self.add_log("üîÑ Navigazione a Genspark...")
                self.driver.get("https://genspark.ai")
                time.sleep(10)

            # Massimo 3 tentativi di invio
            max_attempts = 5

            for attempt in range(max_attempts):
                self.add_log(f"üîÑ Tentativo {attempt+1}/{max_attempts}")
                print(f"DEBUG: Tentativo di invio {attempt+1}/{max_attempts}")

                try:
                    # 1. PREPARAZIONE: Verifica e pulisci la textarea
                    self.add_log("üßπ Inizio pulizia dell'area di input...")
                    print("DEBUG: Pulizia area input...")
    
                    # Attendi che l'input box sia disponibile con timeout lungo
                    input_box = WebDriverWait(self.driver, 20).until(
                        EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper textarea"))
                    )
                    print("DEBUG: Input box trovato")
    
                    # Pulizia in pi√π passaggi (metodo intensivo)
                    input_box.clear()
                    time.sleep(1)
    
                    # Ctrl+A e Delete
                    input_box.send_keys(Keys.CONTROL + "a")
                    time.sleep(0.5)
                    input_box.send_keys(Keys.DELETE)
                    time.sleep(1)
    
                    # Verifica finale con correzione manuale se necessario
                    current_text = input_box.get_attribute("value")
                    if current_text:
                        self.add_log(f"‚ö†Ô∏è Testo residuo: '{current_text}' - pulizia manuale")
                        print(f"DEBUG: Testo residuo dopo pulizia: '{current_text}'")
                        # Metodo manuale: eliminazione carattere per carattere
                        for _ in range(len(current_text) + 5):  # +5 per sicurezza
                            input_box.send_keys(Keys.BACK_SPACE)
                            time.sleep(0.05)
    
                    # Verifica finale
                    final_check = input_box.get_attribute("value")
                    if final_check:
                        self.add_log(f"‚ö†Ô∏è Impossibile pulire completamente: '{final_check}'")
                        print(f"DEBUG: Impossibile pulire completamente: '{final_check}'")
                    else:
                        self.add_log("‚úÖ Area di input completamente pulita")
                        print("DEBUG: Area input pulita con successo")
    
                    # 2. INSERIMENTO TESTO: Carattere per carattere per alta affidabilit√†
                    self.add_log(f"üìù Inserimento testo carattere per carattere...")
                    print(f"DEBUG: Inserimento testo ({len(section_to_send)} caratteri)...")
    
                    # Metodo 1: Per blocchi di 1-2 caratteri (pi√π lento ma pi√π affidabile)
                    block_size = 2  # Numero di caratteri per blocco
                    for i in range(0, len(section_to_send), block_size):
                        block = section_to_send[i:i+block_size]
                        input_box.send_keys(block)
                        time.sleep(0.01)  # Pausa minima tra blocchi
    
                    # Verifica inserimento
                    time.sleep(2)
                    inserted_text = input_box.get_attribute("value")
                    if not inserted_text:
                        self.add_log("‚ùå Nessun testo inserito!")
                        print("DEBUG: ERRORE - Nessun testo inserito!")
                        if attempt < max_attempts - 1:
                            continue
                    elif len(inserted_text) < len(section_to_send) * 0.9:
                        self.add_log(f"‚ö†Ô∏è Testo inserito parzialmente: {len(inserted_text)}/{len(section_to_send)} caratteri")
                        print(f"DEBUG: Testo inserito parzialmente: {len(inserted_text)}/{len(section_to_send)} caratteri")
                        if attempt < max_attempts - 1:
                            continue
                    else:
                        self.add_log(f"‚úÖ Testo inserito correttamente: {len(inserted_text)} caratteri")
                        print(f"DEBUG: Testo inserito correttamente: {len(inserted_text)} caratteri")
    
                    # 3. INVIO: Click sul pulsante con metodi multipli
                    self.add_log("üîò Click sul pulsante di invio...")
                    print("DEBUG: Tentativo click pulsante invio...")
    
                    # Attesa pi√π lunga per il pulsante di invio
                    send_button = WebDriverWait(self.driver, 15).until(
                        EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper div.input-icon"))
                    )
    
                    # Prova entrambi i metodi per maggiore affidabilit√†
                    try:
                        # Metodo 1: Click standard
                        send_button.click()
                        self.add_log("‚úÖ Click standard eseguito")
                        print("DEBUG: Click standard eseguito")
                    except Exception as click_error:
                        self.add_log(f"‚ö†Ô∏è Errore click standard: {str(click_error)}")
                        print(f"DEBUG: Errore click standard: {str(click_error)}")
        
                        # Metodo 2: Click JavaScript
                        try:
                            self.driver.execute_script("arguments[0].click();", send_button)
                            self.add_log("‚úÖ Click JavaScript eseguito")
                            print("DEBUG: Click JavaScript eseguito")
                        except Exception as js_error:
                            self.add_log(f"‚ùå Anche click JavaScript fallito: {str(js_error)}")
                            print(f"DEBUG: Anche click JavaScript fallito: {str(js_error)}")
            
                            # Metodo 3: Invio tramite tasto Enter
                            try:
                                input_box.send_keys(Keys.RETURN)
                                self.add_log("‚úÖ Invio tramite tasto Enter")
                                print("DEBUG: Invio tramite tasto Enter")
                            except Exception as enter_error:
                                self.add_log(f"‚ùå Tutti i metodi di invio falliti: {str(enter_error)}")
                                print(f"DEBUG: Tutti i metodi di invio falliti: {str(enter_error)}")
                                raise Exception("Impossibile inviare il messaggio con nessun metodo")
    
                    # 4. ATTESA RISPOSTA: Sistema di monitoraggio progressivo
                    self.add_log("‚è≥ Attesa iniziale per la risposta (10 secondi)")
                    print("DEBUG: Attesa iniziale per la risposta (10 secondi)")
                    time.sleep(10)  # Attesa iniziale pi√π lunga
    
                    # Verifica che la richiesta non sia stata annullata immediatamente
                    try:
                        error_elements = self.driver.find_elements(By.XPATH, "//*[contains(text(), 'abortita') or contains(text(), 'aborted')]")
                        if error_elements:
                            self.add_log(f"‚ùå Richiesta abortita rilevata immediatamente per domanda #{question_number}")
                            print(f"DEBUG: Richiesta abortita rilevata immediatamente per domanda #{question_number}")
        
                            self.add_log("üßπ Pulisco chat e riprovo lo stesso prompt")
        
                            # Pulisci la conversazione
                            from crisp.ai_interfaces.interaction_utils import clear_chat
                            if clear_chat(self.driver):
                                self.add_log("‚úÖ Chat pulita con successo")
                                time.sleep(30)  # Attesa pi√π lunga (30 secondi)
            
                                if attempt < max_attempts - 1:
                                    self.add_log(f"üîÑ Riprovo domanda #{question_number}, tentativo {attempt+2}/{max_attempts}")
                                    continue  # Riprova nello stesso ciclo di tentativi
                                else:
                                    # Se tutti i tentativi sono falliti, prova un'ultima volta con una pagina pulita
                                    self.add_log(f"‚ö†Ô∏è Ultimo tentativo dopo pulizia chat per domanda #{question_number}")
                                    self.driver.get("https://genspark.ai")
                                    time.sleep(15)
                                    result = self.send_to_genspark(text)  # Chiamata ricorsiva con lo stesso testo
                                    return result if result else update_ui_and_return(f"ERRORE: Richiesta abortita ripetutamente per domanda #{question_number}", success=False, message=f"Richiesta abortita ripetutamente per domanda #{question_number}")
                            else:
                                self.add_log("‚ö†Ô∏è Impossibile pulire la chat")
                                time.sleep(30)  # Attesa pi√π lunga (30 secondi)
            
                                if attempt < max_attempts - 1:
                                    self.add_log(f"üîÑ Nuovo tentativo per domanda #{question_number}")
                                    continue
                                else:
                                    return update_ui_and_return(f"ERRORE: Richiesta abortita ripetutamente per domanda #{question_number}", success=False, message=f"Richiesta abortita ripetutamente per domanda #{question_number}")
                    except Exception:
                        pass  # Ignora errori nella ricerca di messaggi di errore
    
                    # Ciclo di attesa principale
                    response_complete = False
                    last_length = 0
                    stable_count = 0
                    timeout_cycles = 45  # ~15 minuti totali al massimo (20s per ciclo)
                    message_count = 0
    
                    for cycle in range(timeout_cycles):
                        # Debug del ciclo di attesa
                        print(f"DEBUG: Ciclo di attesa {cycle+1}/{timeout_cycles}")
                    
                        # Cerca di ottenere la risposta con metodi multipli
                        response = None
        
                        # 1. Metodo principale: CSS Selector specifico
                        try:
                            selectors = [
                                ".message-content", 
                                "div.chat-wrapper div.desc > div > div > div",
                                "div.message div.text-wrap",
                                ".chat-message-item .content"
                            ]
            
                            for selector in selectors:
                                try:
                                    messages = self.driver.find_elements(By.CSS_SELECTOR, selector)
                                    if messages and len(messages) > 0:
                                        # Controlla se c'√® un nuovo messaggio o un cambio nel conteggio
                                        if len(messages) > message_count:
                                            message_count = len(messages)
                                            self.add_log(f"üì© Nuovo messaggio rilevato: totale {message_count}")
                                            print(f"DEBUG: Nuovo messaggio rilevato: totale {message_count}")
                        
                                        # Usa l'ultimo messaggio
                                        last_message = messages[-1]
                                        response = last_message.text.strip()
                                        if response:
                                            print(f"DEBUG: Risposta trovata con selettore '{selector}': {len(response)} caratteri")
                                        break
                                except Exception:
                                    continue
                        except Exception as e:
                            self.add_log(f"‚ö†Ô∏è Errore nel recupero risposta: {str(e)}")
                            print(f"DEBUG: Errore nel recupero risposta: {str(e)}")
        
                        # 2. Metodo alternativo: JavaScript diretto
                        if not response:
                            try:
                                js_response = self.driver.execute_script("""
                                    var messages = document.querySelectorAll('.message-content, .chat-message-item, .chat-wrapper .desc');
                                    if (messages && messages.length > 0) {
                                        return messages[messages.length - 1].textContent;
                                    }
                                    return null;
                                """)
                
                                if js_response:
                                    response = js_response.strip()
                                    self.add_log(f"üì© Risposta recuperata via JavaScript: {len(response)} caratteri")
                                    print(f"DEBUG: Risposta recuperata via JavaScript: {len(response)} caratteri")
                            except Exception:
                                pass
        
                        # Se abbiamo ottenuto una risposta, analizzala
                        if response:
                            current_length = len(response)
                        
                            # Debug periodico della risposta in crescita
                            if cycle % 5 == 0:  # Ogni 5 cicli
                                preview = response[:150].replace('\n', ' ')
                                print(f"DEBUG: Risposta in corso - {current_length} caratteri - Preview: {preview}...")
            
                            # Controlla gli errori tipici nella risposta
                            error_indicators = ["richiesta abortita", "request aborted", "troppo lungo", "too long", 
                                               "errore durante", "error during", "riprova pi√π tardi", "try again later"]
            
                            if any(indicator in response.lower() for indicator in error_indicators):
                                self.add_log(f"‚ùå Errore rilevato nella risposta: {response[:100]}...")
                                print(f"DEBUG: Errore rilevato nella risposta: {response[:100]}...")
                                if attempt < max_attempts - 1:
                                    time.sleep(10)
                                    break  # Esci dal ciclo e riprova l'invio
                                else:
                                    error_msg = f"ERRORE: {response[:200]}"
                                    return update_ui_and_return(error_msg, success=False, message="Errore rilevato nella risposta")
            
                            # Controlla i terminatori espliciti
                            if "FINE_RISPOSTA" in response or "FINE" in response:
                                # Aggiungi debug dettagliato per il terminatore
                                terminator = "FINE_RISPOSTA" if "FINE_RISPOSTA" in response else "FINE"
                                terminator_pos = response.find(terminator)
                                context_before = response[max(0, terminator_pos-30):terminator_pos]
                                context_after = response[terminator_pos+len(terminator):min(len(response), terminator_pos+len(terminator)+30)]

                                self.add_log(f"üîç TERMINATORE: '{terminator}' trovato alla posizione {terminator_pos} per domanda #{question_number}")
                                self.add_log(f"üîç Contesto: ...{context_before}[{terminator}]{context_after}...")
                                print(f"DEBUG TERMINATORE: '{terminator}' trovato alla posizione {terminator_pos}")
                                print(f"DEBUG TERMINATORE: Contesto: ...{context_before}[{terminator}]{context_after}...")

                                # Continua con la logica esistente
                                self.add_log(f"‚úÖ Terminatore esplicito trovato dopo {cycle+1} cicli per domanda #{question_number}")

                                # Pulisci la risposta rimuovendo il terminatore
                                if "FINE_RISPOSTA" in response:
                                    response = response.split("FINE_RISPOSTA")[0].strip()
                                elif "FINE" in response:
                                    response = response.split("FINE")[0].strip()

                                # Aggiungi una pausa di 30 secondi dopo ogni risposta completa
                                self.add_log("‚è±Ô∏è Pausa di 30 secondi dopo risposta completa")
                                time.sleep(30)

                                return update_ui_and_return(response, success=True, question_number=question_number)
                            else:
                                # Se non viene trovato un terminatore ma la risposta √® stabile
                                if stable_count >= 5:
                                    self.add_log(f"‚ö†Ô∏è Risposta stabilizzata ma SENZA TERMINATORE per domanda #{question_number}")
        
                                    # Verifica se abbiamo ancora tentativi disponibili per questa domanda
                                    if attempt < max_attempts - 1:
                                        self.add_log(f"üîÑ Risposta senza terminatore, riprovo domanda #{question_number}")
            
                                        # Pulisci la chat prima di riprovare
                                        try:
                                            clear_chat(self.driver)
                                            self.add_log(f"üßπ Chat pulita prima di riprovare la domanda #{question_number}")
                                            time.sleep(5)  # Breve pausa dopo pulizia
                                        except Exception as clear_error:
                                            self.add_log(f"‚ö†Ô∏è Errore nella pulizia della chat: {str(clear_error)}")
            
                                        # Attesa prima del nuovo tentativo
                                        wait_time = 15 * (attempt + 1)  # Aumenta il tempo di attesa ad ogni tentativo
                                        self.add_log(f"‚è≥ Attesa di {wait_time} secondi prima del nuovo tentativo...")
                                        time.sleep(wait_time)
            
                                        break  # Esci dal ciclo di attesa e riprova la domanda
                                    else:
                                        # Se abbiamo esaurito i tentativi, registra l'errore
                                        self.add_log(f"‚ùå Tutti i tentativi falliti per domanda #{question_number}: nessun terminatore trovato")
                                        return update_ui_and_return(response, success=False, 
                                                                   message=f"Risposta senza terminatore per domanda #{question_number} dopo {max_attempts} tentativi", 
                                                                   question_number=question_number)
            
                            # Verifica stabilit√† della lunghezza
                            if current_length == last_length:
                                stable_count += 1
                                self.add_log(f"‚è≥ Risposta stabile: {stable_count}/5 cicli ({current_length} caratteri)")
                                print(f"DEBUG: Risposta stabile: {stable_count}/5 cicli ({current_length} caratteri)")
                
                                if stable_count >= 5:  # 5 cicli di stabilit√† = risposta completa
                                    self.add_log(f"‚úÖ Risposta stabilizzata dopo {cycle+1} cicli")
                                    print(f"DEBUG: Risposta stabilizzata dopo {cycle+1} cicli")
                                    return update_ui_and_return(response)
                            else:
                                stable_count = 0
                                self.add_log(f"üìù Risposta in evoluzione: {current_length} caratteri (ciclo {cycle+1})")
                                print(f"DEBUG: Risposta in evoluzione: {current_length} caratteri (ciclo {cycle+1})")
                                last_length = current_length
                        else:
                            self.add_log(f"‚ö†Ô∏è Nessuna risposta rilevabile al ciclo {cycle+1}")
                            print(f"DEBUG: Nessuna risposta rilevabile al ciclo {cycle+1}")
        
                        # Controlla se abbiamo raggiunto un limite di contesto
                        if cycle % 3 == 0:  # Ogni 3 cicli
                            if self.handle_context_limit():
                                self.add_log("‚ôªÔ∏è Limite di contesto rilevato, nuovo tentativo...")
                                print("DEBUG: Limite di contesto rilevato, nuovo tentativo...")
                                return self.send_to_genspark(section_to_send)
        
                        # Attendi prima del prossimo ciclo
                        time.sleep(20)  # 20 secondi tra i cicli
    
                    # Se siamo qui, il timeout √® scaduto
                    if response:
                        self.add_log(f"‚ö†Ô∏è Timeout ma risposta parziale disponibile: {len(response)} caratteri")
                        print(f"DEBUG: Timeout ma risposta parziale disponibile: {len(response)} caratteri")
                        print(f"DEBUG: Salvataggio risposta parziale - Lunghezza: {len(response)}")
                        print(f"DEBUG: Preview risposta parziale: {response[:200].replace(chr(10), ' ')}...")
                        return update_ui_and_return(response, message="Timeout, risposta parziale")
                    else:
                        self.add_log("‚ùå Timeout senza risposta")
                        print("DEBUG: Timeout senza risposta")
        
                        if attempt < max_attempts - 1:
                            retry_delay = 15 * (attempt + 1)  # Aumenta il ritardo ad ogni tentativo
                            self.add_log(f"üîÑ Tentativo {attempt+2} dopo timeout - attesa {retry_delay} secondi")
                            print(f"DEBUG: Tentativo {attempt+2} dopo timeout - attesa {retry_delay} secondi")
                            time.sleep(retry_delay)
                        else:
                            error_msg = "TIMEOUT: Nessuna risposta ricevuta dopo ripetuti tentativi"
                            return update_ui_and_return(error_msg, success=False, message="Timeout senza risposta")
    
                except Exception as e:
                    # Gestione errori specifici per sezione
                    self.add_log(f"‚ö†Ô∏è Errore sezione, tentativo {attempt+1}: {str(e)}")
                    print(f"DEBUG: Errore sezione, tentativo {attempt+1}: {str(e)}")
                
                    # Cattura screenshot per debug
                    try:
                        timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                        screenshot_path = f"error_section_try_{attempt+1}_{timestamp}.png"
                        self.driver.save_screenshot(screenshot_path)
                        self.add_log(f"üì∏ Screenshot: {screenshot_path}")
                        print(f"DEBUG: Screenshot errore: {screenshot_path}")
                    except Exception:
                        pass
                
                    if attempt < max_attempts - 1:
                        attempt_delay = 15 * (attempt + 1)
                        print(f"DEBUG: Attesa {attempt_delay}s prima del prossimo tentativo...")
                        time.sleep(attempt_delay)
                    else:
                        self.add_log("‚ùå Tutti i tentativi falliti")
                        print("DEBUG: Tutti i tentativi falliti")
                        error_msg = f"ERRORE: {str(e)}"
                        return update_ui_and_return(error_msg, success=False, message=str(e))

            # Se arriviamo qui, tutti i tentativi sono falliti
            error_msg = "ERRORE: Tutti i tentativi falliti con errori diversi"
            print("DEBUG: Tutti i tentativi falliti con errori diversi")
            return update_ui_and_return(error_msg, success=False, message="Errori multipli")

        except Exception as e:
            # Errore globale
            error_message = f"ERRORE CRITICO: {str(e)}"
            self.add_log(f"‚ùå {error_message}")
            print(f"DEBUG: ERRORE CRITICO: {str(e)}")
        
            import traceback
            error_trace = traceback.format_exc()
            print(f"DEBUG: Traceback completo:\n{error_trace}")

            # Cattura screenshot finale
            try:
                screenshot_path = f"critical_error_{datetime.now().strftime('%Y%m%d_%H%M%S')}.png"
                self.driver.save_screenshot(screenshot_path)
                self.add_log(f"üì∏ Screenshot errore critico: {screenshot_path}")
                print(f"DEBUG: Screenshot errore critico: {screenshot_path}")
            except Exception:
                pass
    
            return update_ui_and_return(error_message, success=False, message=str(e))

    def _set_use_crisp(self, value):
        """Imposta se usare il framework CRISP"""
        self.use_crisp = value
        if value:
            self.add_log("Framework CRISP 5.0 attivato")
        else:
            self.add_log("Framework CRISP disattivato, verr√† utilizzato il sistema legacy")
    
        # Restituisci il log aggiornato
        return self.chat_manager.get_log_history_string()

    def log_history_string(self):
        """Helper per ottenere il log history come stringa"""
        return self.chat_manager.get_log_history_string()

    def generate_book(self, book_title, book_language, voice_style, book_index):
            """
            Genera il libro utilizzando i dati dell'interfaccia e i dati CRISP disponibili.
            """
            if not book_title.strip():
                return self.add_log("Errore: Il titolo del libro √® obbligatorio!")
            if not book_index.strip():
                return self.add_log("Errore: L'indice del libro √® obbligatorio!")
    
            try:
                # Recupera il tipo di libro
                book_type = "Manuale (Non-Fiction)"  # Default
                if hasattr(self, 'book_type_hidden'):
                    book_type = self.book_type_hidden.value
                elif hasattr(self, 'current_analysis') and self.current_analysis.get('project_data', {}).get('LIBRO_TIPO'):
                    book_type = self.current_analysis['project_data']['LIBRO_TIPO']
        
                self.add_log(f"Generazione libro: {book_title} (Tipo: {book_type})")
        
                # Carica il prompt specifico per questo tipo di libro
                chapter_prompt = self._load_chapter_prompt(book_type)
        
                # Analizza l'indice per ottenere i capitoli
                chapters = self._parse_book_index(book_index)
                self.add_log(f"Indice analizzato: {len(chapters)} capitoli trovati")
        
                # Recupera il contesto completo (dati CRISP)
                context_data = {}
                if hasattr(self, 'current_analysis') and self.current_analysis.get('project_data'):
                    context_data = self.current_analysis['project_data']
        
                # Aggiungi i dati dell'interfaccia al contesto
                context_data['TITOLO_LIBRO'] = book_title
                context_data['LINGUA_LIBRO'] = book_language
                context_data['VOICE_STYLE'] = voice_style
        
                # Genera ogni capitolo
                for i, chapter in enumerate(chapters):
                    self.add_log(f"Generazione capitolo {i+1}/{len(chapters)}: {chapter['title']}")
            
                    # Prepara il prompt per questo capitolo
                    full_prompt = chapter_prompt.replace("{text}", chapter['title'])
            
                    # Sostituisci tutte le variabili dal contesto
                    for var_name, var_value in context_data.items():
                        placeholder = "{" + var_name + "}"
                        if placeholder in full_prompt and var_value:
                            full_prompt = full_prompt.replace(placeholder, str(var_value))
            
                    # Gestisci i placeholder non sostituiti
                    full_prompt = self._handle_missing_placeholders(full_prompt)
            
                    # Invia il prompt e ottieni la risposta
                    chapter_content = self.send_to_genspark(full_prompt)
            
                    # Pulisci la risposta
                    if "FINE_RISPOSTA" in chapter_content:
                        chapter_content = chapter_content.split("FINE_RISPOSTA")[0].strip()
                    elif "FINE" in chapter_content:
                        chapter_content = chapter_content.split("FINE")[0].strip()
            
                    # Salva il capitolo
                    self._save_chapter(chapter['title'], chapter_content, book_title)
            
                    # Applica un cooldown tra i capitoli
                    if i < len(chapters) - 1:
                        cooldown_time = 30 + (i * 5)  # Aumenta progressivamente
                        self.add_log(f"Pausa di {cooldown_time} secondi prima del prossimo capitolo...")
                        time.sleep(cooldown_time)
        
                self.add_log(f"‚úÖ Libro generato con successo: {book_title}")
                return self.chat_manager.get_log_history_string()
        
            except Exception as e:
                error_msg = f"Errore durante la generazione del libro: {str(e)}"
                self.add_log(error_msg)
                logging.error(error_msg)
                return self.chat_manager.get_log_history_string()

    def _parse_book_index(self, book_index):
        """Analizza l'indice e lo converte in una lista di capitoli strutturati."""
        chapters = []
        lines = [line.strip() for line in book_index.split('\n') if line.strip()]
    
        for line in lines:
            # Ignora l'introduzione e la conclusione, li tratteremo separatamente
            if line.lower() in ["introduzione", "introduction", "conclusione", "conclusion"]:
                continue
        
            # Cerca di estrarre il titolo del capitolo
            chapter_match = re.match(r'(?:CAPITOLO|CHAPTER)\s*(\d+)?\s*:?\s*(.*)', line, re.IGNORECASE)
            if chapter_match:
                chapter_number = chapter_match.group(1) or ""
                chapter_title = chapter_match.group(2).strip()
                if chapter_title:
                    chapters.append({
                        "number": chapter_number,
                        "title": chapter_title
                    })
            elif line:  # Se √® una linea con contenuto ma non √® un formato standard
                chapters.append({
                    "number": "",
                    "title": line
                })
    
        return chapters

    def _load_chapter_prompt(self, book_type):
        """Carica il prompt template per i capitoli specifico per il tipo di libro."""
        # Cerca prima in un file, altrimenti usa il template predefinito
        try:
            template_file = f"chapter_prompt_{book_type.lower().replace(' ', '_')}.txt"
            with open(template_file, "r", encoding="utf-8") as f:
                return f.read()
        except:
            # Template predefinito
            return """
            Scrivi il capitolo "{text}" per il libro "{TITOLO_LIBRO}" seguendo rigorosamente queste istruzioni di stile e struttura:
        
            STILE DI SCRITTURA:
            - Utilizza il seguente stile narrativo: {VOICE_STYLE}
            - Mantieni un tono coerente con l'angolo di attacco del libro: {ANGOLO_ATTACCO}
            - Rivolgi il testo direttamente al lettore con le caratteristiche di: {BUYER_PERSONA_SUMMARY}
            - Affronta i problemi principali evidenziati in: {IMPLEMENTATION_OBSTACLES}
        
            STRUTTURA E FORMATTAZIONE:
            - Inizia con un'introduzione coinvolgente che aggancia immediatamente il lettore
            - Dividi il capitolo in 3-5 sezioni principali con sottotitoli chiari
            - Usa tabelle invece di elenchi puntati per presentare informazioni strutturate
            - Includi almeno un esempio pratico o caso studio rilevante
            - Chiudi con un riepilogo dei punti chiave e un collegamento al capitolo successivo
        
            CONTENUTO SPECIFICO:
            - Allinea il contenuto alla Big Idea del libro: {BIG_IDEA}
            - Integra i pilastri di contenuto rilevanti: {CONTENT_PILLARS}
            - Quando applicabile, fai riferimento al metodo proprietario: {PROPRIETARY_METHOD}
        
            Sviluppa il contenuto in modo dettagliato, con una lunghezza compresa tra 2000-3000 parole.
            Scrivi FINE_RISPOSTA quando hai terminato.
            """

    def _handle_missing_placeholders(self, text):
        """Gestisce i placeholder non sostituiti nel prompt."""
        # Trova tutti i placeholder rimanenti
        placeholders = re.findall(r'\{([A-Z_]+)\}', text)
    
        for placeholder in placeholders:
            # Sostituisce i placeholder mancanti con un valore generico
            full_placeholder = "{" + placeholder + "}"
            text = text.replace(full_placeholder, f"[Valore di {placeholder} non disponibile]")
    
        return text

    def _generate_chapter_content(self, chapter_title, prompt):
        """Genera il contenuto di un capitolo inviandolo a Genspark."""
        try:
            # Verifica se il driver √® attivo
            if not self.driver:
                self.add_log("Browser non disponibile")
                return "Errore: Browser non disponibile"
        
            # Ottieni l'input box
            input_box = WebDriverWait(self.driver, 20).until(
                EC.element_to_be_clickable((By.CSS_SELECTOR, "div.search-input-wrapper textarea"))
            )
        
            if not input_box:
                self.add_log("Impossibile ottenere l'input box")
                return "Errore: Input box non disponibile"
        
            # Invia il prompt e attendi la risposta
            response = self.send_to_genspark(prompt)
        
            # Pulisci la risposta
            if "FINE_RISPOSTA" in response:
                response = response.split("FINE_RISPOSTA")[0].strip()
            elif "FINE" in response:
                response = response.split("FINE")[0].strip()
        
            return response
    
        except Exception as e:
            self.add_log(f"Errore nella generazione del capitolo {chapter_title}: {str(e)}")
            return f"Errore nella generazione: {str(e)}"

    def _save_chapter(self, chapter_title, chapter_content, book_title):
        """Salva il capitolo generato in un file."""
        from docx import Document
    
        safe_title = re.sub(r'[<>:"/\\|?*]', '', book_title)
        folder_path = os.path.join(os.getcwd(), safe_title)
        os.makedirs(folder_path, exist_ok=True)
    
        safe_chapter = re.sub(r'[<>:"/\\|?*]', '', chapter_title)
        file_path = os.path.join(folder_path, f"{safe_chapter}.docx")
    
        doc = Document()
        doc.add_heading(chapter_title, 1)
    
        # Aggiungi il contenuto con formattazione di base
        for paragraph in chapter_content.split('\n\n'):
            if paragraph.strip():
                if paragraph.strip().startswith('#'):
                    # √à un titolo
                    level = paragraph.count('#')
                    title_text = paragraph.strip('#').strip()
                    doc.add_heading(title_text, level)
                else:
                    # √à un paragrafo normale
                    doc.add_paragraph(paragraph)
    
        doc.save(file_path)
        self.add_log(f"Capitolo '{chapter_title}' salvato in {file_path}")
    
        return file_path  

    def load_analysis_results(self):
        """
        Carica i risultati dell'analisi nell'interfaccia utente
        """
        self.add_log("Caricamento dei risultati dell'analisi...")
    
        try:
            # Verifica che il file di contesto esista
            context_file = "context.txt"
            if not os.path.exists(context_file):
                self.add_log("‚ö†Ô∏è File context.txt non trovato")
                if hasattr(self, 'results_display'):
                    self.results_display.update(value="<div class='alert alert-warning'>File dei risultati non trovato. Esegui prima l'analisi.</div>")
                return self.chat_manager.get_log_history_string()
        
            # Leggi il file di contesto
            with open(context_file, "r", encoding="utf-8") as f:
                context_content = f.read()
        
            if not context_content.strip():
                self.add_log("‚ö†Ô∏è File context.txt vuoto")
                if hasattr(self, 'results_display'):
                    self.results_display.update(value="<div class='alert alert-warning'>File dei risultati vuoto. Esegui l'analisi.</div>")
                return self.chat_manager.get_log_history_string()
        
            # Estrai le sezioni del contesto
            sections = []
            section_pattern = r'===\s+([^=]+?)\s+-\s+\d{8}_\d{6}\s+===\n(.*?)(?=\n===|$)'
            section_matches = re.findall(section_pattern, context_content, re.DOTALL)
        
            if section_matches:
                sections = [(title.strip(), content.strip()) for title, content in section_matches]
                self.add_log(f"‚úÖ Estratte {len(sections)} sezioni")
            
                # Debug: mostra dimensione delle prime 3 sezioni
                for i, (title, content) in enumerate(sections[:3]):
                    self.add_log(f"Sezione {i+1}: {title} ({len(content)} caratteri)")
            else:
                # Fallback: divide per numeri
                number_pattern = r'(\d+\).*?)(?=\d+\)|$)'
                number_matches = re.findall(number_pattern, context_content, re.DOTALL)
            
                if number_matches:
                    sections = [(f"Sezione {i+1}", content.strip()) for i, content in enumerate(number_matches)]
                    self.add_log(f"‚úÖ Estratte {len(sections)} sezioni (pattern numerico)")
                else:
                    # Ultimo fallback: usa il testo completo
                    sections = [("Risultati completi", context_content)]
                    self.add_log("‚ö†Ô∏è Nessuna sezione trovata, usando il testo completo")
        
            # Costruisci l'HTML per la visualizzazione
            html = """
            <!DOCTYPE html>
            <html>
            <head>
                <style>
                    body { font-family: Arial, sans-serif; }
                    .header { background-color: #2563eb; color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; }
                    .section { background-color: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 15px; }
                    .section-title { font-weight: bold; font-size: 18px; margin-bottom: 10px; }
                    .error { background-color: #fee2e2; }
                    .ok { background-color: #d1fae5; }
                </style>
            </head>
            <body>
                <div class="header">
                    <h2>Risultati dell'Analisi</h2>
                    <p>Sezioni trovate: %d</p>
                </div>
                <div>
            """ % len(sections)
        
            # Aggiungi le sezioni
            for title, content in sections:
                # Determina se √® una risposta valida o un errore
                is_error = "richiesta abortita" in content.lower() or len(content) < 30
                section_class = "section error" if is_error else "section ok"
            
                # Converti newline in <br> per HTML
                content_html = content.replace("\n", "<br>")
            
                html += """
                <div class="%s">
                    <div class="section-title">%s</div>
                    <div>%s</div>
                </div>
                """ % (section_class, title, content_html)
        
            html += """
                </div>
            </body>
            </html>
            """
        
            # Salva l'HTML per diagnostica
            with open("debug_html_output.html", "w", encoding="utf-8") as f:
                f.write(html)
            self.add_log(f"HTML di debug salvato: debug_html_output.html ({len(html)} bytes)")
        
            # IMPORTANTE: Verifica che results_display esista e sia diverso da analysis_status
            if hasattr(self, 'results_display'):
                # Verifica se results_display e analysis_status sono lo stesso oggetto
                same_object = False
                if hasattr(self, 'analysis_status'):
                    same_object = id(self.results_display) == id(self.analysis_status)
                    self.add_log(f"DEBUG: results_display e analysis_status sono {'LO STESSO' if same_object else 'OGGETTI DIVERSI'}")
            
                # Aggiorna l'interfaccia SOLO se non sono lo stesso oggetto
                if not same_object:
                    self.results_display.update(value=html)
                    self.add_log("‚úÖ Risultati dell'analisi visualizzati nell'interfaccia")
                
                    # Aggiorna lo stato dell'analisi separatamente
                    if hasattr(self, 'analysis_status'):
                        self.analysis_status.update(value="**Stato analisi**: Completata e visualizzata ‚úÖ")
                else:
                    self.add_log("‚ö†Ô∏è results_display e analysis_status sono lo stesso oggetto! Non aggiorno l'interfaccia")
                    # In questo caso, dobbiamo aggiornare solo uno dei due
                    self.results_display.update(value=html)
                    self.add_log("‚úÖ Risultati dell'analisi visualizzati nell'interfaccia (solo results_display)")
            else:
                self.add_log("‚ö†Ô∏è results_display non disponibile")
        
            return self.chat_manager.get_log_history_string()
    
        except Exception as e:
            self.add_log(f"‚ùå Errore nel caricamento dei risultati: {str(e)}")
            import traceback
            self.add_log(traceback.format_exc())
            return self.chat_manager.get_log_history_string()

    def export_to_docx(self):
        """Esporta l'analisi corrente in un documento DOCX."""
        try:
            self.add_log("Esportazione in DOCX...")
        
            # 1. Determina quale file di contesto utilizzare
            keyword = self.get_current_keyword() if hasattr(self, 'get_current_keyword') else "unknown"
        
            # Ottieni il nome del file sanitizzato
            import re
            safe_keyword = re.sub(r'[\\/*?:"<>|]', "", keyword).replace(" ", "_")[:30]
            context_file = f"context_{safe_keyword}.txt"
        
            # Se il file specifico non esiste, prova con il file di contesto generico
            if not os.path.exists(context_file):
                self.add_log(f"‚ö†Ô∏è File specifico {context_file} non trovato, provo con il file generico")
                context_file = "context.txt"
            
                if not os.path.exists(context_file):
                    self.add_log("‚ùå Nessun file di contesto trovato!")
                    return None
        
            self.add_log(f"üìÑ Utilizzo del file di contesto: {context_file}")
        
            # 2. Leggi il contenuto del file
            with open(context_file, "r", encoding="utf-8") as f:
                content = f.read()
        
            # 3. Crea il documento
            from docx import Document
            doc = Document()
            doc.add_heading(f"Analisi di mercato: {keyword}", 0)
        
            # Aggiungi informazioni sul documento
            timestamp = datetime.now().strftime("%d/%m/%Y %H:%M:%S")
            doc.add_paragraph(f"Generato il: {timestamp}")
            doc.add_paragraph(f"Keyword: {keyword}")
            doc.add_paragraph("")  # Spazio aggiuntivo
        
            # 4. Dividi il contenuto in sezioni e aggiungile al documento
            sections = []
            section_pattern = r'===\s+([^=]+?)\s+-\s+\d{8}_\d{6}\s+===\n(.*?)(?=\n===|$)'
            section_matches = re.findall(section_pattern, content, re.DOTALL)
        
            if section_matches:
                sections = [(title.strip(), content.strip()) for title, content in section_matches]
                self.add_log(f"‚úÖ Estratte {len(sections)} sezioni per il documento")
            else:
                # Fallback: divide per "==="
                raw_sections = content.split("===")
                for i, section in enumerate(raw_sections):
                    if section.strip():
                        sections.append((f"Sezione {i+1}", section.strip()))
                self.add_log(f"‚ö†Ô∏è Estratte {len(sections)} sezioni usando metodo fallback")
        
            # 5. Aggiungi ogni sezione al documento con formattazione appropriata
            for section_title, section_content in sections:
                # Aggiungi il titolo della sezione
                doc.add_heading(section_title, level=1)
            
                # Dividi il contenuto in paragrafi
                paragraphs = section_content.split('\n\n')
                for paragraph_text in paragraphs:
                    if paragraph_text.strip():
                        # Verifica se √® un titolo di paragrafo
                        lines = paragraph_text.splitlines()
                        if lines and len(lines) > 1 and len(lines[0]) < 100 and lines[0].endswith(':'):
                            # Sembra un titolo di paragrafo
                            doc.add_heading(lines[0], level=2)
                            paragraph = doc.add_paragraph("\n".join(lines[1:]))
                        else:
                            # Paragrafo normale
                            paragraph = doc.add_paragraph(paragraph_text)
                
                # Aggiungi un divisore tra le sezioni
                doc.add_paragraph("")
        
            # 6. Salva il documento con un nome significativo
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            output_path = f"analisi_{safe_keyword}_{timestamp}.docx"
            doc.save(output_path)
        
            self.add_log(f"‚úÖ Documento DOCX salvato: {output_path}")
            return output_path
    
        except Exception as e:
            self.add_log(f"‚ùå Errore nell'esportazione DOCX: {str(e)}")
            import traceback
            self.add_log(traceback.format_exc())
            return None

    def export_to_pdf(self):
        try:
            self.add_log("Esportazione in PDF...")
        
            # 1. Prima esporta in DOCX
            docx_path = self.export_to_docx()
            if not docx_path:
                raise Exception("Errore nell'esportazione DOCX preliminare")
        
            # 2. Converti DOCX in PDF - metodo preferito: python-docx2pdf
            try:
                # Prova a importare docx2pdf
                from docx2pdf import convert
            
                # Conversione diretta
                pdf_path = docx_path.replace('.docx', '.pdf')
                self.add_log(f"Conversione {docx_path} in {pdf_path}...")
                convert(docx_path, pdf_path)
            
                self.add_log(f"‚úÖ Documento PDF salvato: {pdf_path}")
                return pdf_path
            
            except ImportError:
                # Fallback: utilizza un messaggio informativo se docx2pdf non √® installato
                self.add_log("‚ö†Ô∏è Modulo python-docx2pdf non trovato.")
                self.add_log("‚ö†Ô∏è Per convertire in PDF, apri il file DOCX e usa 'Salva come PDF'")
                self.add_log(f"‚ö†Ô∏è Il file DOCX √® disponibile qui: {docx_path}")
                return docx_path
        
        except Exception as e:
            self.add_log(f"‚ùå Errore nell'esportazione PDF: {str(e)}")
            import traceback
            self.add_log(traceback.format_exc())
            return None

    def export_to_txt(self):
        try:
            self.add_log("Esportazione in TXT...")
        
            # 1. Verifica se esiste il file di contesto
            context_file = "context.txt"
            if not os.path.exists(context_file):
                self.add_log("‚ùå File context.txt non trovato!")
                return None
        
            # 2. Ottieni la keyword corrente o usa un valore predefinito
            keyword = self.get_current_keyword() if hasattr(self, 'get_current_keyword') else "unknown"
        
            # 3. Crea la directory di output se non esiste
            output_dir = os.path.join(os.getcwd(), "output")
            os.makedirs(output_dir, exist_ok=True)
        
            # 4. Prepara il percorso del file di output
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            output_path = os.path.join(output_dir, f"analisi_{keyword}_{timestamp}.txt")
        
            # 5. Copia il file di contesto nel file di output
            import shutil
            shutil.copy2(context_file, output_path)
        
            self.add_log(f"‚úÖ File TXT salvato: {output_path}")
            return output_path
        except Exception as e:
            self.add_log(f"‚ùå Errore nell'esportazione TXT: {str(e)}")
            import traceback
            self.add_log(traceback.format_exc())
            return None

    def debug_check_components(self):
        """Verifica se results_display e analysis_status sono lo stesso oggetto"""
        if hasattr(self, 'results_display') and hasattr(self, 'analysis_status'):
            same_object = id(self.results_display) == id(self.analysis_status)
            self.add_log(f"DEBUG: results_display e analysis_status sono {'LO STESSO' if same_object else 'OGGETTI DIVERSI'}")
            self.add_log(f"DEBUG: ID results_display: {id(self.results_display)}")
            self.add_log(f"DEBUG: ID analysis_status: {id(self.analysis_status)}")
        else:
            self.add_log("DEBUG: Uno o entrambi i componenti non esistono ancora")
        return self.chat_manager.get_log_history_string()

    def load_saved_analyses_list(self):
            """Carica l'elenco delle analisi salvate"""
            saved_analyses = []
            try:
                # Cerca i file context_*.txt nella directory corrente
                for file in os.listdir():
                    match = re.match(r'context_(.+)\.txt', file)
                    if match:
                        keyword = match.group(1).replace('_', ' ')
                        saved_analyses.append(keyword)
                    
                return saved_analyses
            except Exception as e:
                self.add_log(f"Errore nel caricamento delle analisi salvate: {str(e)}")
                return []
    
    def load_saved_analysis(self, keyword):
        """Carica un'analisi salvata"""
        try:
            # Converti la keyword in nome file
            file_keyword = keyword.replace(' ', '_')
            context_file = f"context_{file_keyword}.txt"
        
            if not os.path.exists(context_file):
                self.add_log(f"‚ùå Analisi per '{keyword}' non trovata!")
                return self.chat_manager.get_log_history_string()
            
            # Leggi il file
            with open(context_file, "r", encoding="utf-8") as f:
                content = f.read()
              
            # Imposta come analisi corrente
            self.current_analysis = {"KEYWORD": keyword}
          
            # Aggiorna l'interfaccia
            self.add_log(f"‚úÖ Analisi per '{keyword}' caricata con successo")
            
            # Carica i risultati nell'interfaccia
            self.load_analysis_results(context_file)
            
            return self.chat_manager.get_log_history_string()
            
        except Exception as e:
            self.add_log(f"Errore nel caricamento dell'analisi: {str(e)}")
            return self.chat_manager.get_log_history_string()

    def get_current_keyword(self):
        """Recupera la keyword corrente dall'interfaccia o dai dati di progetto"""
        try:
            # Metodo 1: Controlla se la keyword √® disponibile nell'interfaccia
            if hasattr(self, 'keyword') and hasattr(self.keyword, 'value'):
                return self.keyword.value or "unknown"
        
            # Metodo 2: Controlla i dati del progetto corrente
            if hasattr(self, 'current_analysis') and self.current_analysis:
                project_data = self.current_analysis.get('project_data', {})
                if 'KEYWORD' in project_data:
                    return project_data['KEYWORD']
        
            # Metodo 3: Cerca nel file di contesto
            context_file = "context.txt"
            if os.path.exists(context_file):
                with open(context_file, "r", encoding="utf-8") as f:
                    content = f.read()
                    import re
                    keyword_match = re.search(r'keyword "([^"]+)"', content, re.IGNORECASE)
                    if keyword_match:
                        return keyword_match.group(1)
        
            return "unknown"
        except Exception as e:
            self.add_log(f"‚ö†Ô∏è Errore nel recupero della keyword: {str(e)}")
            return "unknown"

    def create_interface(self):
        with gr.Blocks(title="PubliScript 2.0", theme="soft") as interface:
            # Header principale
            with gr.Row(elem_classes=["header-container"]):
                gr.HTML("""
                    <div class="app-header">
                        <div class="logo-container">
                            <span class="logo-icon">üìï</span>
                            <h1>PubliScript 2.0</h1>
                        </div>
                        <div class="app-subtitle">Sistema Multi-Agente per Analisi e Generazione di Libri</div>
                    </div>
                """)
        
            # Sistema di tabs principale
            with gr.Tabs(elem_classes=["main-tabs"]) as tabs:
                # Tab 1: Setup & Connessione
                with gr.TabItem("1Ô∏è‚É£ Setup & Connessione", elem_classes=["tab-content"]):
                    with gr.Row():
                        with gr.Column(scale=1):
                            gr.Markdown("### Connessione al Servizio")
                            connect_btn = gr.Button("üîå Connetti a Genspark", variant="primary")
                    
                            gr.Markdown("### Framework di Generazione")
                            use_crisp_toggle = gr.Checkbox(
                                label="Usa Framework CRISP",
                                value=True,
                                info="Attiva il framework CRISP per un'analisi pi√π strutturata"
                            )
                    
                        with gr.Column(scale=2):
                            connection_status = gr.Markdown("**Stato**: Non connesso")
                    
                            # Area di log
                            self.log_output = gr.TextArea(
                                label="Console di sistema",
                                interactive=False,
                                lines=15,
                                value="Sistema inizializzato. Connettiti per iniziare.",
                                elem_id="log-output-area"
                            )
                    
                            # Pulsante per pulire i log
                            clear_log_btn = gr.Button("üßπ Pulisci Log", variant="secondary", size="sm")
            
                # Tab 2: Analisi di Mercato
                with gr.TabItem("2Ô∏è‚É£ Analisi di Mercato", elem_classes=["tab-content"]):
                    with gr.Row():
                        # Colonna sinistra: Input (1/3)
                        with gr.Column(scale=1, elem_classes=["input-column"]):
                            gr.Markdown("### Informazioni Base")
            
                            # Nuovo controllo per caricare analisi esistente
                            with gr.Row():
                                load_analysis_dropdown = gr.Dropdown(
                                    choices=self.load_saved_analyses_list(),
                                    label="Carica Analisi Esistente",
                                    interactive=True,
                                    elem_classes=["dropdown-input"]
                                )
                                load_analysis_btn = gr.Button("üìÇ Carica", variant="secondary")
            
                            book_type = gr.Dropdown(
                                choices=self.book_types,
                                label="Tipo di Libro",
                                value=self.book_types[0],
                                elem_classes=["dropdown-input"]
                            )
            
                            keyword = gr.Textbox(
                                label="Keyword Principale",
                                placeholder="Parola chiave principale del libro",
                                elem_classes=["text-input"]
                            )
                        
                            language = gr.Dropdown(
                                choices=["English", "Espa√±ol", "Fran√ßais", "Deutsch", "Italiano"],
                                label="Lingua Output Analisi",
                                value="Italiano",
                                elem_classes=["dropdown-input"]
                            )
                        
                            market = gr.Dropdown(
                                choices=list(self.markets.keys()),
                                label="Mercato di Riferimento",
                                value="USA",
                                elem_classes=["dropdown-input"]
                            )
                        
                            # Opzioni avanzate
                            with gr.Accordion("Mostra opzioni avanzate", open=False):
                                analysis_prompt = gr.TextArea(
                                    label="Prompt di Analisi (opzionale)",
                                    value=self.default_analysis_prompt,
                                    lines=6
                                )
                        
                            # Aggiunta dell'Accordion per la selezione delle fasi
                            with gr.Accordion("üìã Seleziona fasi analisi", open=False):
                                gr.Markdown("### Scegli le fasi dell'analisi da eseguire")
    
                                with gr.Row():
                                    analysis_type_radio = gr.Radio(
                                        choices=["CRISP", "Legacy"],
                                        label="Tipo di Analisi",
                                        value="CRISP",
                                        interactive=True
                                    )
    
                                # Fasi per l'analisi CRISP
                                with gr.Column(visible=True) as crisp_phases_col:
                                    gr.Markdown("#### Fasi Analisi CRISP")
                                    crisp_phases = [
                                        ("CM-1", "Analisi del mercato e dei bestseller"),
                                        ("CM-2", "Struttura e pattern dei titoli"),
                                        ("CM-3", "Analisi dei concorrenti principali"),
                                        ("CM-4", "Definizione buyer persona"),
                                        ("CM-5", "Analisi gap e recensioni negative"),
                                        ("CM-6", "Generazione idee editoriali"),
                                        ("CM-7", "Valutazione delle idee"),
                                        ("CM-8", "Proposta titoli e indice")
                                    ]
        
                                    self.crisp_phase_checkboxes = {}
                                    with gr.Row(equal_height=True):
                                        for i, (phase_id, phase_desc) in enumerate(crisp_phases[:4]):
                                            self.crisp_phase_checkboxes[phase_id] = gr.Checkbox(
                                                label=f"{phase_id}: {phase_desc}",
                                                value=True,
                                                elem_id=f"crisp_phase_{phase_id}"
                                            )
        
                                    with gr.Row(equal_height=True):
                                        for i, (phase_id, phase_desc) in enumerate(crisp_phases[4:]):
                                            self.crisp_phase_checkboxes[phase_id] = gr.Checkbox(
                                                label=f"{phase_id}: {phase_desc}",
                                                value=True,
                                                elem_id=f"crisp_phase_{phase_id}"
                                            )
    
                                # Fasi per l'analisi Legacy
                                with gr.Column(visible=False) as legacy_phases_col:
                                    gr.Markdown("#### Fasi Analisi Legacy")
                                    legacy_phases = [
                                        (1, "Analisi concorrenza e bestseller"),
                                        (2, "Profittabilit√† e competitivit√†"),
                                        (3, "Analisi dei 3 migliori concorrenti"),
                                        (4, "Definizione buyer persona"),
                                        (5, "Gap e recensioni negative"),
                                        (6, "Generazione idee editoriali"),
                                        (7, "Valutazione idee proposte"),
                                        (8, "Proposta titoli e indici")
                                    ]
        
                                    self.legacy_phase_checkboxes = {}
                                    with gr.Row(equal_height=True):
                                        for i, (phase_id, phase_desc) in enumerate(legacy_phases[:4]):
                                            self.legacy_phase_checkboxes[phase_id] = gr.Checkbox(
                                                label=f"#{phase_id}: {phase_desc}",
                                                value=True,
                                                elem_id=f"legacy_phase_{phase_id}"
                                            )
        
                                    with gr.Row(equal_height=True):
                                        for i, (phase_id, phase_desc) in enumerate(legacy_phases[4:]):
                                            self.legacy_phase_checkboxes[phase_id] = gr.Checkbox(
                                                label=f"#{phase_id}: {phase_desc}",
                                                value=True,
                                                elem_id=f"legacy_phase_{phase_id}"
                                            )
    
                                # Pulsante "Seleziona/Deseleziona tutto"
                                with gr.Row():
                                    select_all_btn = gr.Button("‚úÖ Seleziona tutto", variant="secondary", size="sm")
                                    deselect_all_btn = gr.Button("‚ùå Deseleziona tutto", variant="secondary", size="sm")

                                # Collega i radio button al cambio di visibilit√†
                                analysis_type_radio.change(
                                    fn=lambda x: (
                                        gr.update(visible=(x == "CRISP")), 
                                        gr.update(visible=(x == "Legacy"))
                                    ),
                                    inputs=[analysis_type_radio],
                                    outputs=[crisp_phases_col, legacy_phases_col]
                                )

                                # Collega i pulsanti di selezione/deselezione alle rispettive funzioni
                                select_all_outputs = list(self.crisp_phase_checkboxes.values()) + list(self.legacy_phase_checkboxes.values())
                                deselect_all_outputs = list(self.crisp_phase_checkboxes.values()) + list(self.legacy_phase_checkboxes.values())

                                select_all_btn.click(
                                    fn=self.select_all_phases,
                                    inputs=[analysis_type_radio],
                                    outputs=select_all_outputs
                                )

                                deselect_all_btn.click(
                                    fn=self.deselect_all_phases,
                                    inputs=[analysis_type_radio],
                                    outputs=deselect_all_outputs
                                )
                            
                            analyze_btn = gr.Button("üîç Analizza Mercato", variant="primary", size="lg")
                            complete_analysis_btn = gr.Button("‚úÖ Completa Analisi", variant="secondary")
                
                        # Colonna destra: Output (2/3)
                        with gr.Column(scale=2, elem_classes=["output-column"]):
                            gr.Markdown("### Analisi di Mercato")
                        
                            # Stato analisi
                            analysis_status = gr.Markdown("**Stato analisi**: Non iniziata", elem_classes=["status-text"])
                        
                            # Pulsanti di esportazione
                            with gr.Row(elem_classes=["export-buttons"]):
                                export_docx_btn = gr.Button("üìÑ Esporta DOCX", variant="secondary")
                                export_pdf_btn = gr.Button("üìë Esporta PDF", variant="secondary")
                                export_txt_btn = gr.Button("üìù Esporta TXT", variant="secondary")
                                debug_btn = gr.Button("üêû Debug UI", variant="secondary")

                            # Area di output principale (formato HTML per ricchezza)
                            results_display = gr.HTML(
                                value="<div class='results-placeholder'>I risultati dell'analisi appariranno qui</div>",
                                elem_classes=["results-container"]
                            )
            
                # Tab 3: Generazione Libro
                with gr.TabItem("3Ô∏è‚É£ Generazione Libro", elem_classes=["tab-content"]):
                    with gr.Group(visible=True) as book_details:
                        gr.Markdown("### Dettagli Libro")
                    
                        with gr.Row():
                            with gr.Column(scale=1):
                                # Aggiungi questo campo di sola lettura per mostrare il tipo di libro
                                book_type_display = gr.Textbox(
                                    label="Tipo di Libro",
                                    value="",
                                    interactive=False,
                                    elem_classes=["text-input"]
                                )
                            
                                with gr.Row():
                                    with gr.Column(scale=1):
                                        self.book_title = gr.Textbox(
                                            label="Titolo del Libro",
                                            placeholder="Inserisci il titolo",
                                            elem_classes=["text-input"]
                                        )
                                
                                        self.book_language = gr.Textbox(
                                            label="Lingua del Libro",
                                            value="English",
                                            placeholder="es: English, Italiano, Espa√±ol",
                                            elem_classes=["text-input"]
                                        )
                                
                                        self.voice_style = gr.Textbox(
                                            label="Tono di Voce",
                                            placeholder="es: Formale, Tecnico, Conversazionale",
                                            value="",
                                            elem_classes=["text-input"]
                                        )
                            
                                    with gr.Column(scale=2):
                                        self.book_index = gr.TextArea(
                                            label="Indice del Libro",
                                            placeholder="Inserisci l'indice, un capitolo per riga",
                                            lines=10,
                                            elem_classes=["text-area"]
                                        )
                            
                                generate_btn = gr.Button("üìö Genera Libro", variant="primary", size="lg")
            
                # Tab 4: Database & Gestione
                with gr.TabItem("4Ô∏è‚É£ Database & Gestione", elem_classes=["tab-content"]):
                    with gr.Row():
                        with gr.Column(scale=1):
                            gr.Markdown("### Progetti Salvati")
            
                            # Opzioni di manutenzione
                            with gr.Row():
                                diagnose_db_btn = gr.Button("üõ†Ô∏è Ripara Database", variant="primary")
                                create_test_btn = gr.Button("üß™ Crea Progetto Test", variant="secondary")
            
                            # Ricerca e filtri
                            with gr.Row():
                                search_keyword = gr.Textbox(
                                    label="Cerca per keyword",
                                    placeholder="Inserisci una keyword...",
                                    show_label=True,
                                    elem_classes=["text-input"]
                                )
                        
                                refresh_db_btn = gr.Button("üîÑ Carica Progetti", variant="primary")
                        
                            # Lista progetti
                            projects_list = gr.Dropdown(
                                label="Seleziona un Progetto",
                                choices=[],
                                interactive=True,
                                elem_id="projects_dropdown",
                                elem_classes=["dropdown-input"],
                                type="value"
                            )
      
                            self.projects_list = projects_list
                        
                            # Azioni progetti
                            with gr.Row():
                                resume_btn = gr.Button("‚ñ∂Ô∏è Ripristina Analisi", variant="primary")
                                export_btn = gr.Button("üì§ Esporta", variant="secondary")
                                delete_btn = gr.Button("üóëÔ∏è Elimina", variant="stop")
                
                        with gr.Column(scale=2):
                            gr.Markdown("### Dettagli Progetto")
                        
                            # Dettagli progetto in formato HTML
                            project_details = gr.HTML(
                                value="<div class='project-placeholder'>Seleziona un progetto per visualizzarne i dettagli</div>",
                                elem_classes=["project-details"]
                            )
            
                # Tab 5: Debug & Sviluppo
                with gr.TabItem("5Ô∏è‚É£ Debug & Sviluppo", elem_classes=["tab-content"]):
                    with gr.Row():
                        with gr.Column():
                            gr.Markdown("### Strumenti Debug")
                        
                            with gr.Row():
                                take_screenshot_btn = gr.Button("üì∏ Screenshot Browser", variant="secondary")
                                reset_context_btn = gr.Button("‚ôªÔ∏è Reset Context Limit", variant="secondary")
                        
                            debug_output = gr.TextArea(
                                label="Output Debug",
                                interactive=False,
                                lines=10,
                                value=""
                            )

            # CSS personalizzato e librerie esterne
            gr.HTML("""
                <!-- Font Awesome per le icone -->
                <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">

                <!-- Tailwind CSS per lo styling avanzato -->
                <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">

                <!-- Google Fonts per tipografia migliorata (opzionale) -->
                <link rel="preconnect" href="https://fonts.googleapis.com">
                <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
                <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">

                <style>
                    /* Stile generale */
                    body {
                        font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
                    }

                    /* Header */
                    .app-header {
                        display: flex;
                        flex-direction: column;
                        align-items: center;
                        margin-bottom: 1rem;
                        background: linear-gradient(to right, #2563eb, #4f46e5);
                        color: white;
                        padding: 1rem;
                        border-radius: 0.5rem;
                        width: 100%;
                        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                    }

                    .logo-container {
                        display: flex;
                        align-items: center;
                    }

                    .logo-icon {
                        font-size: 2rem;
                        margin-right: 0.5rem;
                    }

                    .app-header h1 {
                        margin: 0;
                        font-size: 1.8rem;
                        font-weight: 700;
                    }

                    .app-subtitle {
                        margin-top: 0.25rem;
                        font-size: 1rem;
                        opacity: 0.9;
                    }

                    /* Tabs */
                    .main-tabs button {
                        font-weight: 600;
                        padding: 0.75rem 1rem;
                        transition: all 0.2s ease;
                    }

                    .main-tabs button:hover {
                        background-color: #f3f4f6;
                    }

                    .main-tabs button.active {
                        border-bottom: 2px solid #3b82f6;
                        color: #1e40af;
                    }

                    .tab-content {
                        padding: 1rem 0;
                    }

                    /* Input fields */
                    .input-column {
                        border-right: 1px solid #e5e7eb;
                        padding-right: 1rem;
                    }

                    .text-input, .dropdown-input, .text-area {
                        margin-bottom: 1rem;
                        transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
                    }

                    .text-input:focus, .dropdown-input:focus, .text-area:focus {
                        border-color: #3b82f6;
                        box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.25);
                    }

                    /* Output display */
                    .status-text {
                        background-color: #f3f4f6;
                        padding: 0.5rem;
                        border-radius: 0.375rem;
                        margin-bottom: 0.5rem;
                    }

                    .export-buttons {
                        margin-bottom: 1rem;
                        padding: 0.5rem 0;
                        border-bottom: 1px solid #e5e7eb;
                    }

                    .results-container {
                        border: 1px solid #e5e7eb;
                        border-radius: 0.5rem;
                        padding: 1rem;
                        background-color: #f9fafb;
                        min-height: 500px;
                        max-height: 70vh;
                        overflow-y: auto;
                        box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.06);
                    }

                    .results-placeholder {
                        text-align: center;
                        color: #6b7280;
                        padding: 2rem;
                        font-style: italic;
                    }

                    /* Project details */
                    .project-details {
                        border: 1px solid #e5e7eb;
                        border-radius: 0.5rem;
                        padding: 1rem;
                        background-color: #f9fafb;
                        min-height: 400px;
                        max-height: 70vh;
                        overflow-y: auto;
                        transition: all 0.3s ease;
                    }

                    .project-details:hover {
                        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                    }

                    .project-placeholder {
                        text-align: center;
                        color: #6b7280;
                        padding: 2rem;
                        font-style: italic;
                    }

                    /* Card style per i risultati */
                    .data-card {
                        background-color: white;
                        border-radius: 0.5rem;
                        box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px 0 rgba(0, 0, 0, 0.06);
                        padding: 1rem;
                        margin-bottom: 1rem;
                        transition: all 0.3s ease;
                    }

                    .data-card:hover {
                        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
                        transform: translateY(-2px);
                    }

                    .data-card-title {
                        font-weight: 600;
                        color: #2563eb;
                        margin-bottom: 0.5rem;
                        display: flex;
                        align-items: center;
                    }

                    .data-card-title i {
                        margin-right: 0.5rem;
                    }

                    /* Scrollbar customization */
                    *::-webkit-scrollbar {
                        width: 8px;
                    }

                    *::-webkit-scrollbar-track {
                        background: #f1f1f1;
                        border-radius: 4px;
                    }

                    *::-webkit-scrollbar-thumb {
                        background: #888;
                        border-radius: 4px;
                    }

                    *::-webkit-scrollbar-thumb:hover {
                        background: #555;
                    }

                    /* Miglioramenti per pulsanti */
                    button {
                        transition: all 0.2s ease;
                    }

                    button:hover {
                        transform: translateY(-1px);
                    }

                    button:active {
                        transform: translateY(1px);
                    }

                    /* Classi di utilit√† per flexbox */
                    .flex-center {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    }

                    .flex-between {
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                    }

                    /* Badge e tag */
                    .badge {
                        display: inline-block;
                        padding: 0.25rem 0.75rem;
                        border-radius: 9999px;
                        font-size: 0.75rem;
                        font-weight: 600;
                        margin-right: 0.5rem;
                    }

                    .badge-blue {
                        background-color: #dbeafe;
                        color: #1e40af;
                    }

                    .badge-green {
                        background-color: #d1fae5;
                        color: #065f46;
                    }

                    .badge-yellow {
                        background-color: #fef3c7;
                        color: #92400e;
                    }

                    .badge-red {
                        background-color: #fee2e2;
                        color: #b91c1c;
                    }

                    /* Stili per i risultati dell'analisi */
                    .analysis-results .section-card {
                        transition: all 0.2s ease;
                    }

                    .analysis-results .section-card:hover {
                        transform: translateY(-2px);
                    }

                    .analysis-results .badge {
                        display: inline-block;
                        padding: 0.25rem 0.75rem;
                        border-radius: 9999px;
                        font-size: 0.75rem;
                        font-weight: 600;
                    }

                    .analysis-results .content {
                        font-size: 0.9rem;
                        line-height: 1.5;
                    }

                    .metadata-box {
                        border-left: 4px solid #3b82f6;
                    }

                    .metadata-item {
                        margin-bottom: 0.5rem;
                    }
                </style>

                <script>
                    // Funzione per mostrare/nascondere le colonne delle fasi in base al tipo di analisi
                    function togglePhaseColumns(analysisType) {
                        const crispCol = document.querySelector('[id$="crisp_phases_col"]');
                        const legacyCol = document.querySelector('[id$="legacy_phases_col"]');
        
                        if (analysisType === "CRISP") {
                            if (crispCol) crispCol.style.display = "block";
                            if (legacyCol) legacyCol.style.display = "none";
                        } else {
                            if (crispCol) crispCol.style.display = "none";
                            if (legacyCol) legacyCol.style.display = "block";
                        }
                    }

                    // Inizializza l'interfaccia dopo il caricamento
                    document.addEventListener('DOMContentLoaded', function() {
                        setTimeout(function() {
                            // Trova i radio button
                            const radioInputs = document.querySelectorAll('input[type="radio"][name$="analysis_type_radio"]');
            
                            // Aggiungi event listener a ciascun radio button
                            radioInputs.forEach(input => {
                                input.addEventListener('change', function() {
                                    togglePhaseColumns(this.value);
                                });
                            });
            
                            // Imposta lo stato iniziale
                            const selectedRadio = document.querySelector('input[type="radio"][name$="analysis_type_radio"]:checked');
                            if (selectedRadio) {
                                togglePhaseColumns(selectedRadio.value);
                            }
                
                            // Seleziona tutti i tab e aggiunge la classe active al primo
                            const tabs = document.querySelectorAll('.main-tabs button');
                            if (tabs.length > 0) {
                                tabs[0].classList.add('active');
                            }

                            // Aggiungi event listener per cambiare il tab attivo
                            tabs.forEach(tab => {
                                tab.addEventListener('click', function() {
                                    tabs.forEach(t => t.classList.remove('active'));
                                    this.classList.add('active');
                                });
                            });
                        }, 500); // Breve delay per assicurarsi che l'interfaccia sia caricata
                    });
                </script>
            """)
       
            # Function handlers
    
            # Funzione per pulire i log
            def clear_logs():
                self.log_history = ["Log cancellato."]
                return self.chat_manager.get_log_history_string()
    
            clear_log_btn.click(fn=clear_logs, outputs=self.log_output)
    
            # Connessione
            connect_btn.click(
                fn=self.connect_callback,
                outputs=[self.log_output, connection_status],
                show_progress=False
            )
    
            # Uso CRISP
            use_crisp_toggle.change(
                fn=self._set_use_crisp,
                inputs=use_crisp_toggle,
                outputs=self.log_output
            )
    
            # Analisi mercato
            analyze_btn.click(
                fn=self.analyze_market,
                inputs=[book_type, keyword, language, market, analysis_prompt],
                outputs=self.log_output,
                show_progress=False
            )
    
            # Completa analisi
            complete_analysis_btn.click(
                fn=self.complete_analysis,
                outputs=[self.log_output, analysis_status, tabs, self.book_title, self.book_index, self.voice_style]
            )
    
            # Generazione libro
            generate_btn.click(
                fn=self.generate_book,
                inputs=[self.book_title, self.book_language, self.voice_style, self.book_index],
                outputs=self.log_output
            )
    
            # Database e gestione progetti
            refresh_db_btn.click(
                fn=self.load_projects_list,
                outputs=[projects_list]
            )

            # AGGIUNGI QUESTO
            create_test_btn.click(
                fn=self.create_test_project,
                outputs=[project_details]
            )
    
            projects_list.change(
                fn=self.load_project_details,
                inputs=projects_list,
                outputs=[project_details]
            )
    
            resume_btn.click(
                fn=self.ripristina_analisi_da_database,
                inputs=projects_list,
                outputs=self.log_output
            )
    
            export_btn.click(
                fn=self.export_project,
                inputs=projects_list,
                outputs=self.log_output
            )
    
            delete_btn.click(
                fn=lambda project_name: [
                    self.delete_project(project_name),
                    self.load_projects_list(),
                    "<div style='text-align: center'><p>Progetto eliminato</p></div>"
                ],
                inputs=projects_list,
                outputs=[self.log_output, projects_list, project_details]
            )

            # Nel metodo create_interface, dopo aver definito load_analysis_btn:
            load_analysis_btn.click(
                fn=self.load_saved_analysis,
                inputs=[load_analysis_dropdown],
                outputs=[self.log_output]
            )

            debug_btn.click(
                fn=self.debug_check_components,
                outputs=[self.log_output]
            )
    
            # Debug tools
            take_screenshot_btn.click(
                fn=lambda: self.take_debug_screenshot("debug"),
                outputs=debug_output
            )
    
            reset_context_btn.click(
                fn=self.handle_context_limit,
                outputs=self.log_output
            )

            # Connetti gli eventi per i pulsanti di esportazione
            export_docx_btn.click(
                fn=self.export_to_docx,
                outputs=[self.log_output]
            )
    
            export_pdf_btn.click(
                fn=self.export_to_pdf,
                outputs=[self.log_output]
            )
    
            export_txt_btn.click(
                fn=self.export_to_txt,
                outputs=[self.log_output]
            )
    
            # AGGIUNGI QUESTO
            diagnose_db_btn.click(
                fn=self.diagnose_and_fix_database,
                outputs=[project_details]  # Mostra risultati nel riquadro dettagli progetto
            )

            return interface

    def format_analysis_results_html(self, keyword, market, book_type, language, context=None):
        # """
        # Formatta i risultati dell'analisi in HTML per una visualizzazione migliore.
        #
        # Args:
        #     keyword: Keyword analizzata
        #     market: Mercato target
        #     book_type: Tipo di libro
        #     language: Lingua dell'output
        #     context: Dati di contesto aggiuntivi (opzionale)
        #
        # Returns:
        #     str: HTML formattato con i risultati
        # """
        try:
            self.add_log("üé® Formattazione risultati in HTML")
        
            # 1. Leggi il file di contesto
            context_file = "context.txt"
            context_content = ""
            if os.path.exists(context_file):
                with open(context_file, "r", encoding="utf-8") as f:
                    context_content = f.read()
                    self.add_log(f"‚úÖ File contesto letto: {len(context_content)} caratteri")
            else:
                self.add_log("‚ö†Ô∏è File context.txt non trovato")
        
            # 2. Estrai le sezioni dell'analisi
            sections = []
            section_pattern = r'===\s+([^=]+?)\s+-\s+\d{8}_\d{6}\s+===\n(.*?)(?=\n===|$)'
            section_matches = re.findall(section_pattern, context_content, re.DOTALL)
        
            if section_matches:
                sections = [(title.strip(), content.strip()) for title, content in section_matches]
                self.add_log(f"‚úÖ Estratte {len(sections)} sezioni dal contesto")
            else:
                # Fallback: divide il testo per numeri progressivi
                number_pattern = r'(\d+\).*?)(?=\d+\)|$)'
                number_matches = re.findall(number_pattern, context_content, re.DOTALL)
            
                if number_matches:
                    sections = [(f"Sezione {i+1}", content.strip()) for i, content in enumerate(number_matches)]
                    self.add_log(f"‚úÖ Estratte {len(sections)} sezioni numeriche alternate")
                else:
                    # Ultimo fallback: usa il testo completo come sezione unica
                    sections = [("Risultati completi", context_content)]
                    self.add_log("‚ö†Ô∏è Impossibile estrarre sezioni, usando contenuto completo")
        
            # 3. Estrai metadati chiave dal context dictionary se disponibile
            metadata_html = ""
            if context and isinstance(context, dict):
                # Estrai solo metadati selezionati
                important_metadata = [
                    ('MARKET_INSIGHTS', 'Insight di Mercato'),
                    ('BUYER_PERSONA_SUMMARY', 'Profilo Buyer Persona'),
                    ('ANGOLO_ATTACCO', 'Angolo di Attacco'),
                    ('PROMESSA_PRINCIPALE', 'Promessa Principale'),
                    ('BIG_IDEA', 'Big Idea'),
                    ('TITOLO_LIBRO', 'Titolo Proposto')
                ]
            
                metadata_items = []
                for key, label in important_metadata:
                    if key in context and context[key]:
                        value = context[key]
                        # Limita lunghezza per non sovraccaricare la UI
                        if isinstance(value, str) and len(value) > 200:
                            value = value[:197] + "..."
                        metadata_items.append(f"<div class='metadata-item'><strong>{label}:</strong> {value}</div>")
            
                if metadata_items:
                    metadata_html = f"""
                    <div class="metadata-box bg-blue-50 p-4 rounded-lg mb-4">
                        <h3 class="text-md font-bold mb-2 text-blue-800">Dati Chiave Estratti:</h3>
                        {"".join(metadata_items)}
                    </div>
                    """
                    self.add_log(f"‚úÖ Generati metadati HTML con {len(metadata_items)} elementi")
        
            # 4. Costruisci l'HTML completo
            result_html = f"""
            <div class="analysis-results">
                <div class="header bg-gradient-to-r from-blue-600 to-indigo-700 text-white p-4 rounded-lg mb-4">
                    <h2 class="text-xl font-bold">Analisi di Mercato: {keyword}</h2>
                    <div class="flex flex-wrap gap-2 mt-2">
                        <div class="badge bg-blue-200 text-blue-800 px-2 py-1 rounded">Mercato: {market}</div>
                        <div class="badge bg-blue-200 text-blue-800 px-2 py-1 rounded">Tipo: {book_type}</div>
                        <div class="badge bg-blue-200 text-blue-800 px-2 py-1 rounded">Lingua: {language}</div>
                    </div>
                </div>
        
                {metadata_html}
        
                <div class="results-container">
            """
        
            # 5. Aggiungi ciascuna sezione come card
            for title, content in sections:
                # Pulisci il titolo
                clean_title = re.sub(r'\d+\)\s*', '', title).strip()
                clean_title = clean_title.replace('**', '')  # Rimuovi markdown
            
                # Determina l'icona in base al titolo
                icon = "üìä"  # Default
                if "concorrenti" in title.lower() or "top 3" in title.lower():
                    icon = "üèÜ"
                elif "profittabilit√†" in title.lower():
                    icon = "üí∞"
                elif "buyer persona" in title.lower():
                    icon = "üë§"
                elif "recensioni" in title.lower() or "gap" in title.lower():
                    icon = "üîç"
                elif "angolo" in title.lower() or "usp" in title.lower():
                    icon = "üéØ"
                elif "titolo" in title.lower():
                    icon = "üìù"
                elif "indice" in title.lower():
                    icon = "üìë"
            
                # Aggiungi la card della sezione
                result_html += f"""
                <div class="section-card bg-white p-4 rounded-lg shadow mb-4 hover:shadow-lg transition-shadow">
                    <h3 class="text-lg font-bold mb-2 text-gray-800">{icon} {clean_title}</h3>
                    <div class="content whitespace-pre-line text-gray-700">{content}</div>
                </div>
                """
        
            # 6. Chiudi l'HTML
            result_html += """
                </div>
            </div>
            """
        
            self.add_log("‚úÖ HTML dei risultati generato con successo")
            return result_html
    
        except Exception as e:
            error_html = f"""
            <div class="error-message bg-red-50 border-l-4 border-red-500 p-4">
                <h3 class="text-red-700 font-bold">Errore nella formattazione dei risultati</h3>
                <p class="text-red-600">{str(e)}</p>
                <p class="text-gray-700 mt-2">I dati sono stati salvati ma non possono essere visualizzati correttamente.</p>
            </div>
            """
            self.add_log(f"‚ùå Errore nella formattazione HTML: {str(e)}")
            import traceback
            self.add_log(traceback.format_exc())
            return error_html

    def process_text(self, text):
        """Processa il testo con formattazione di base"""
        if not text:
            return "<em class='text-gray-500'>Nessun dato disponibile</em>"
        
        # Sostituisci ** con tag bold
        if '**' in text:
            parts = text.split('**')
            result = ""
            for i, part in enumerate(parts):
                if i % 2 == 0:  # Testo normale
                    result += part
                else:  # Testo in grassetto
                    result += f"<strong>{part}</strong>"
            return result
    
        return text

    def process_list_html(self, content, list_type):
        """Formatta una lista in HTML"""
        if not content:
            return "<p>Nessun elemento disponibile</p>"
    
        # Estrai elementi della lista
        items = []
        current_item = ""
    
        # Dividi per righe e cerca elementi numerati o con trattino
        for line in content.strip().split('\n'):
            line = line.strip()
            if line.startswith('- ') or re.match(r'^\d+\.', line):
                if current_item:
                    items.append(current_item)
                # Rimuovi il prefisso (- o numero.)
                if line.startswith('- '):
                    current_item = line[2:]
                else:
                    # Trova la posizione del punto
                    dot_pos = line.find('.')
                    if dot_pos > 0:
                        current_item = line[dot_pos + 1:].strip()
            elif line:
                if current_item:
                    current_item += " " + line
                else:
                    current_item = line
    
        if current_item:
            items.append(current_item)
    
        if not items:
            return f"<p>{self.process_text(content)}</p>"
    
        # Definisci classi CSS in base al tipo
        bg_class = ""
        if list_type == "REVIEW_INSIGHTS":
            bg_class = "bg-red-50"
        elif list_type == "IMPLEMENTATION_OBSTACLES":
            bg_class = "bg-yellow-50"
        elif list_type == "MARKET_GAPS":
            bg_class = "bg-green-50"
    
        # Crea la lista HTML
        html = '<ul class="space-y-3">'
        for i, item in enumerate(items):
            html += f"""
            <li class="{bg_class} p-3 rounded-lg flex items-start">
                <div class="rounded-full bg-blue-100 text-blue-800 h-6 w-6 flex items-center justify-center mr-3 mt-1 flex-shrink-0">{i+1}</div>
                <div>
                    <p class="font-medium">{self.process_text(item)}</p>
                </div>
            </li>
            """
        html += '</ul>'
    
        return html

    def process_patterns_html(self, content, pattern_type):
        """Formatta pattern di titoli o strutture in HTML"""
        if not content:
            return "<p>Nessun pattern disponibile</p>"
    
        # Semplice controllo per tabelle
        if content.strip().startswith('|') and content.strip().endswith('|'):
            return self.process_table_html(content)
    
        # Estrai pattern
        patterns = []
        current_pattern = ""
    
        for line in content.strip().split('\n'):
            line = line.strip()
            if line.startswith('- ') or re.match(r'^\d+\.', line):
                if current_pattern:
                    patterns.append(current_pattern)
                # Rimuovi il prefisso (- o numero.)
                if line.startswith('- '):
                    current_pattern = line[2:]
                else:
                    # Trova la posizione del punto
                    dot_pos = line.find('.')
                    if dot_pos > 0:
                        current_pattern = line[dot_pos + 1:].strip()
            elif line:
                if current_pattern:
                    current_pattern += " " + line
                else:
                    current_pattern = line
    
        if current_pattern:
            patterns.append(current_pattern)
    
        if not patterns:
            return f"<p>{self.process_text(content)}</p>"
    
        # Crea layout appropriato in base al tipo
        if pattern_type == "TITLE_PATTERNS":
            html = '<div class="space-y-3">'
            for i, pattern in enumerate(patterns):
                # Dividi il pattern in titolo e esempio
                parts = pattern.split(' - ', 1)
                title = parts[0].strip()
                example = parts[1].strip() if len(parts) > 1 else ""
            
                html += f"""
                <div class="bg-blue-50 p-3 rounded-lg">
                    <span class="badge bg-blue-100 text-blue-800 px-2 py-1 rounded-full text-xs">Pattern {i+1}</span>
                    <span class="font-semibold">{self.process_text(title)}</span>
                    <p class="mt-1 text-gray-700">Es: <span class="italic">{self.process_text(example)}</span></p>
                </div>
                """
            html += '</div>'
        else:  # STRUCTURE_PATTERNS
            html = '<div class="grid grid-cols-2 gap-4">'
            for i, pattern in enumerate(patterns):
                # Dividi in titolo e descrizione
                parts = pattern.split(':', 1)
                title = parts[0].strip()
                description = parts[1].strip() if len(parts) > 1 else ""
            
                html += f"""
                <div class="bg-indigo-50 p-3 rounded-lg">
                    <h4 class="font-semibold text-indigo-700">{self.process_text(title)}</h4>
                    <p class="mt-2">{self.process_text(description)}</p>
                </div>
                """
            html += '</div>'
    
        return html

    def process_table_html(self, content):
        """Converte una tabella in formato markdown in HTML"""
        if not content or '|' not in content:
            return f"<p>{self.process_text(content)}</p>"
    
        # Dividi le righe
        rows = content.strip().split('\n')
    
        # Se non abbiamo almeno 2 righe (intestazione + separatore), non √® una tabella valida
        if len(rows) < 2:
            return f"<p>{self.process_text(content)}</p>"
    
        html = '<div class="overflow-x-auto"><table class="data-table w-full">'
    
        # Processa intestazione
        header_cells = [cell.strip() for cell in rows[0].strip('|').split('|')]
    
        html += '<thead><tr>'
        for cell in header_cells:
            html += f'<th class="text-left py-2 px-4 bg-gray-50">{self.process_text(cell)}</th>'
        html += '</tr></thead><tbody>'
    
        # Salta l'intestazione e il separatore
        for row in rows[2:]:
            if '---' in row:  # Ignora eventuali altri separatori
                continue
            
            cells = [cell.strip() for cell in row.strip('|').split('|')]
            html += '<tr>'
            for cell in cells:
                html += f'<td class="py-2 px-4 border-t">{self.process_text(cell)}</td>'
            html += '</tr>'
    
        html += '</tbody></table></div>'
        return html

# AGGIUNGERE QUESTO CODICE ALLA FINE DEL FILE book_builder.py

# Invece di sostituire il metodo a livello di classe, utilizziamo una funzione
# che applica il patching a un'istanza specifica

def apply_debug_patching(builder_instance):
    """
    Applica il debug patching al metodo send_to_genspark di un'istanza di AIBookBuilder
    
    Args:
        builder_instance: Istanza di AIBookBuilder a cui applicare il patching
    """
    # Salva il metodo originale dall'istanza (non dalla classe)
    original_method = builder_instance.send_to_genspark
    
    # Definisci il nuovo metodo con debug
    def debug_send_to_genspark(self, text, prompt_id=None, section_number=None):
        """Versione con debug del metodo send_to_genspark"""
        print(f"DEBUG_SEND: Invio testo a Genspark ({len(text)} caratteri)")
        print(f"DEBUG_SEND: Primi 50 caratteri del testo: {text[:50]}")
        
        if prompt_id:
            print(f"DEBUG_SEND: Prompt ID: {prompt_id}, Sezione: {section_number}")
            
        if hasattr(self, 'driver') and self.driver:
            print(f"DEBUG_SEND: URL attuale prima dell'invio: {self.driver.current_url}")
            
        import traceback
        caller = traceback.extract_stack()[-2]
        print(f"DEBUG_SEND: Chiamata da {caller.filename}:{caller.lineno}")
        
        # Chiama il metodo originale
        result = original_method(text, prompt_id, section_number)
        
        if hasattr(self, 'driver') and self.driver:
            print(f"DEBUG_SEND: URL attuale dopo l'invio: {self.driver.current_url}")
            
        if result:
            has_end = "FINE_RISPOSTA" in result or "FINE" in result
            print(f"DEBUG_SEND: Risultato ({len(result)} chars) - Contiene FINE_RISPOSTA: {has_end}")
            print(f"DEBUG_SEND: Preview inizio: {result[:100]}...")
            
            if len(result) > 200:
                print(f"DEBUG_SEND: Preview fine: ...{result[-200:]}")
            else:
                print(f"DEBUG_SEND: Preview fine: {result}")
        else:
            print("DEBUG_SEND: Nessun risultato ottenuto")
            
        return result
    
    # Sostituisci il metodo nell'istanza usando la tecnica dei tipi
    import types
    builder_instance.send_to_genspark = types.MethodType(debug_send_to_genspark, builder_instance)
    
    print("Debug patching applicato all'istanza AIBookBuilder")
    return True
